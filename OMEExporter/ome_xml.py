#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Mar 17 15:07:59 2015 by generateDS.py version 2.15a.
#
# Command line options:
#   ('--export', 'etree')
#   ('-o', 'ome.py')
#   ('-s', 'ome_subs.py')
#
# Command line arguments:
#   ome.xsd
#
# Command line:
#   generateDS.py --export="etree" -o "ome.py" -s "ome_subs.py" ome.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.15a
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(*args, **kwargs):
    if 'parser' not in kwargs:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class OME(GeneratedsSuper):
    """The OME element is a container for all information objects
    accessible by OME. These information objects include
    descriptions of the imaging experiments and the people who
    perform them, descriptions of the microscope, the resulting
    images and how they were acquired, the analyses performed on
    those images, and the analysis results themselves. An OME file
    may contain any or all of this information. This unique
    identifier is used to keep track of multi part files. It allows
    the links between files to survive renaming."""
    subclass = None
    superclass = None
    def __init__(self, UUID=None, Project=None, Dataset=None, Experiment=None, Plate=None, Screen=None, Experimenter=None, Group=None, Instrument=None, Image=None, StructuredAnnotations=None, ROI=None):
        self.original_tagname_ = None
        self.UUID = _cast(None, UUID)
        if Project is None:
            self.Project = []
        else:
            self.Project = Project
        if Dataset is None:
            self.Dataset = []
        else:
            self.Dataset = Dataset
        if Experiment is None:
            self.Experiment = []
        else:
            self.Experiment = Experiment
        if Plate is None:
            self.Plate = []
        else:
            self.Plate = Plate
        if Screen is None:
            self.Screen = []
        else:
            self.Screen = Screen
        if Experimenter is None:
            self.Experimenter = []
        else:
            self.Experimenter = Experimenter
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        if Instrument is None:
            self.Instrument = []
        else:
            self.Instrument = Instrument
        if Image is None:
            self.Image = []
        else:
            self.Image = Image
        self.StructuredAnnotations = StructuredAnnotations
        if ROI is None:
            self.ROI = []
        else:
            self.ROI = ROI
    def factory(*args_, **kwargs_):
        if OME.subclass:
            return OME.subclass(*args_, **kwargs_)
        else:
            return OME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Project(self): return self.Project
    def set_Project(self, Project): self.Project = Project
    def add_Project(self, value): self.Project.append(value)
    def insert_Project_at(self, index, value): self.Project.insert(index, value)
    def replace_Project_at(self, index, value): self.Project[index] = value
    def get_Dataset(self): return self.Dataset
    def set_Dataset(self, Dataset): self.Dataset = Dataset
    def add_Dataset(self, value): self.Dataset.append(value)
    def insert_Dataset_at(self, index, value): self.Dataset.insert(index, value)
    def replace_Dataset_at(self, index, value): self.Dataset[index] = value
    def get_Experiment(self): return self.Experiment
    def set_Experiment(self, Experiment): self.Experiment = Experiment
    def add_Experiment(self, value): self.Experiment.append(value)
    def insert_Experiment_at(self, index, value): self.Experiment.insert(index, value)
    def replace_Experiment_at(self, index, value): self.Experiment[index] = value
    def get_Plate(self): return self.Plate
    def set_Plate(self, Plate): self.Plate = Plate
    def add_Plate(self, value): self.Plate.append(value)
    def insert_Plate_at(self, index, value): self.Plate.insert(index, value)
    def replace_Plate_at(self, index, value): self.Plate[index] = value
    def get_Screen(self): return self.Screen
    def set_Screen(self, Screen): self.Screen = Screen
    def add_Screen(self, value): self.Screen.append(value)
    def insert_Screen_at(self, index, value): self.Screen.insert(index, value)
    def replace_Screen_at(self, index, value): self.Screen[index] = value
    def get_Experimenter(self): return self.Experimenter
    def set_Experimenter(self, Experimenter): self.Experimenter = Experimenter
    def add_Experimenter(self, value): self.Experimenter.append(value)
    def insert_Experimenter_at(self, index, value): self.Experimenter.insert(index, value)
    def replace_Experimenter_at(self, index, value): self.Experimenter[index] = value
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group_at(self, index, value): self.Group.insert(index, value)
    def replace_Group_at(self, index, value): self.Group[index] = value
    def get_Instrument(self): return self.Instrument
    def set_Instrument(self, Instrument): self.Instrument = Instrument
    def add_Instrument(self, value): self.Instrument.append(value)
    def insert_Instrument_at(self, index, value): self.Instrument.insert(index, value)
    def replace_Instrument_at(self, index, value): self.Instrument[index] = value
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def add_Image(self, value): self.Image.append(value)
    def insert_Image_at(self, index, value): self.Image.insert(index, value)
    def replace_Image_at(self, index, value): self.Image[index] = value
    def get_StructuredAnnotations(self): return self.StructuredAnnotations
    def set_StructuredAnnotations(self, StructuredAnnotations): self.StructuredAnnotations = StructuredAnnotations
    def get_ROI(self): return self.ROI
    def set_ROI(self, ROI): self.ROI = ROI
    def add_ROI(self, value): self.ROI.append(value)
    def insert_ROI_at(self, index, value): self.ROI.insert(index, value)
    def replace_ROI_at(self, index, value): self.ROI[index] = value
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def validate_UniversallyUniqueIdentifier(self, value):
        # Validate type UniversallyUniqueIdentifier, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_UniversallyUniqueIdentifier_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_UniversallyUniqueIdentifier_patterns_, ))
    validate_UniversallyUniqueIdentifier_patterns_ = [['^(urn:uuid:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$']]
    def hasContent_(self):
        if (
            self.Project or
            self.Dataset or
            self.Experiment or
            self.Plate or
            self.Screen or
            self.Experimenter or
            self.Group or
            self.Instrument or
            self.Image or
            self.StructuredAnnotations is not None or
            self.ROI
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OME', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.UUID is not None:
            element.set('UUID', self.UUID)
        for Project_ in self.Project:
            Project_.to_etree(element, name_='Project', mapping_=mapping_)
        for Dataset_ in self.Dataset:
            Dataset_.to_etree(element, name_='Dataset', mapping_=mapping_)
        for Experiment_ in self.Experiment:
            Experiment_.to_etree(element, name_='Experiment', mapping_=mapping_)
        for Plate_ in self.Plate:
            Plate_.to_etree(element, name_='Plate', mapping_=mapping_)
        for Screen_ in self.Screen:
            Screen_.to_etree(element, name_='Screen', mapping_=mapping_)
        for Experimenter_ in self.Experimenter:
            Experimenter_.to_etree(element, name_='Experimenter', mapping_=mapping_)
        for Group_ in self.Group:
            Group_.to_etree(element, name_='Group', mapping_=mapping_)
        for Instrument_ in self.Instrument:
            Instrument_.to_etree(element, name_='Instrument', mapping_=mapping_)
        for Image_ in self.Image:
            Image_.to_etree(element, name_='Image', mapping_=mapping_)
        if self.StructuredAnnotations is not None:
            StructuredAnnotations_ = self.StructuredAnnotations
            StructuredAnnotations_.to_etree(element, name_='StructuredAnnotations', mapping_=mapping_)
        for ROI_ in self.ROI:
            ROI_.to_etree(element, name_='ROI', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
            self.validate_UniversallyUniqueIdentifier(self.UUID)    # validate type UniversallyUniqueIdentifier
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Project':
            obj_ = Project.factory()
            obj_.build(child_)
            self.Project.append(obj_)
            obj_.original_tagname_ = 'Project'
        elif nodeName_ == 'Dataset':
            obj_ = Dataset.factory()
            obj_.build(child_)
            self.Dataset.append(obj_)
            obj_.original_tagname_ = 'Dataset'
        elif nodeName_ == 'Experiment':
            obj_ = Experiment.factory()
            obj_.build(child_)
            self.Experiment.append(obj_)
            obj_.original_tagname_ = 'Experiment'
        elif nodeName_ == 'Plate':
            obj_ = Plate.factory()
            obj_.build(child_)
            self.Plate.append(obj_)
            obj_.original_tagname_ = 'Plate'
        elif nodeName_ == 'Screen':
            obj_ = Screen.factory()
            obj_.build(child_)
            self.Screen.append(obj_)
            obj_.original_tagname_ = 'Screen'
        elif nodeName_ == 'Experimenter':
            obj_ = Experimenter.factory()
            obj_.build(child_)
            self.Experimenter.append(obj_)
            obj_.original_tagname_ = 'Experimenter'
        elif nodeName_ == 'Group':
            obj_ = Group.factory()
            obj_.build(child_)
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
        elif nodeName_ == 'Instrument':
            obj_ = Instrument.factory()
            obj_.build(child_)
            self.Instrument.append(obj_)
            obj_.original_tagname_ = 'Instrument'
        elif nodeName_ == 'Image':
            obj_ = Image.factory()
            obj_.build(child_)
            self.Image.append(obj_)
            obj_.original_tagname_ = 'Image'
        elif nodeName_ == 'StructuredAnnotations':
            obj_ = StructuredAnnotations.factory()
            obj_.build(child_)
            self.StructuredAnnotations = obj_
            obj_.original_tagname_ = 'StructuredAnnotations'
        elif nodeName_ == 'ROI':
            obj_ = ROI.factory()
            obj_.build(child_)
            self.ROI.append(obj_)
            obj_.original_tagname_ = 'ROI'
# end class OME


class Image(GeneratedsSuper):
    """This element describes the actual image and its meta-data. The
    elements that are references (ending in Ref or Settings) refer
    to elements defined outside of the Image element. Ref elements
    are simple links, while Settings elements are links with
    additional values. If any of the required Image attributes or
    elements are missing, its guaranteed to be an invalid document.
    The required attributes and elements are ID and Pixels.
    ExperimenterRef is required for all Images with well formed
    LSIDs. ImageType is a vendor-specific designation of the type of
    image this is. Examples of ImageType include 'STK', 'SoftWorx',
    etc. The Name attributes are in all cases the name of the
    element instance. In this case, the name of the image, not
    necessarily the filename. PixelSize* is in microns[um]."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Name=None, AcquiredDate=None, ExperimenterRef=None, Description=None, ExperimentRef=None, GroupRef=None, DatasetRef=None, InstrumentRef=None, ObjectiveSettings=None, ImagingEnvironment=None, StageLabel=None, Pixels=None, ROIRef=None, MicrobeamManipulationRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Name = _cast(None, Name)
        if isinstance(AcquiredDate, basestring):
            initvalue_ = datetime_.datetime.strptime(AcquiredDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = AcquiredDate
        self.AcquiredDate = initvalue_
        self.ExperimenterRef = ExperimenterRef
        self.Description = Description
        self.validate_DescriptionType(self.Description)
        self.ExperimentRef = ExperimentRef
        self.GroupRef = GroupRef
        if DatasetRef is None:
            self.DatasetRef = []
        else:
            self.DatasetRef = DatasetRef
        self.InstrumentRef = InstrumentRef
        self.ObjectiveSettings = ObjectiveSettings
        self.ImagingEnvironment = ImagingEnvironment
        self.StageLabel = StageLabel
        self.Pixels = Pixels
        if ROIRef is None:
            self.ROIRef = []
        else:
            self.ROIRef = ROIRef
        if MicrobeamManipulationRef is None:
            self.MicrobeamManipulationRef = []
        else:
            self.MicrobeamManipulationRef = MicrobeamManipulationRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AcquiredDate(self): return self.AcquiredDate
    def set_AcquiredDate(self, AcquiredDate): self.AcquiredDate = AcquiredDate
    def get_ExperimenterRef(self): return self.ExperimenterRef
    def set_ExperimenterRef(self, ExperimenterRef): self.ExperimenterRef = ExperimenterRef
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ExperimentRef(self): return self.ExperimentRef
    def set_ExperimentRef(self, ExperimentRef): self.ExperimentRef = ExperimentRef
    def get_GroupRef(self): return self.GroupRef
    def set_GroupRef(self, GroupRef): self.GroupRef = GroupRef
    def get_DatasetRef(self): return self.DatasetRef
    def set_DatasetRef(self, DatasetRef): self.DatasetRef = DatasetRef
    def add_DatasetRef(self, value): self.DatasetRef.append(value)
    def insert_DatasetRef_at(self, index, value): self.DatasetRef.insert(index, value)
    def replace_DatasetRef_at(self, index, value): self.DatasetRef[index] = value
    def get_InstrumentRef(self): return self.InstrumentRef
    def set_InstrumentRef(self, InstrumentRef): self.InstrumentRef = InstrumentRef
    def get_ObjectiveSettings(self): return self.ObjectiveSettings
    def set_ObjectiveSettings(self, ObjectiveSettings): self.ObjectiveSettings = ObjectiveSettings
    def get_ImagingEnvironment(self): return self.ImagingEnvironment
    def set_ImagingEnvironment(self, ImagingEnvironment): self.ImagingEnvironment = ImagingEnvironment
    def get_StageLabel(self): return self.StageLabel
    def set_StageLabel(self, StageLabel): self.StageLabel = StageLabel
    def get_Pixels(self): return self.Pixels
    def set_Pixels(self, Pixels): self.Pixels = Pixels
    def get_ROIRef(self): return self.ROIRef
    def set_ROIRef(self, ROIRef): self.ROIRef = ROIRef
    def add_ROIRef(self, value): self.ROIRef.append(value)
    def insert_ROIRef_at(self, index, value): self.ROIRef.insert(index, value)
    def replace_ROIRef_at(self, index, value): self.ROIRef[index] = value
    def get_MicrobeamManipulationRef(self): return self.MicrobeamManipulationRef
    def set_MicrobeamManipulationRef(self, MicrobeamManipulationRef): self.MicrobeamManipulationRef = MicrobeamManipulationRef
    def add_MicrobeamManipulationRef(self, value): self.MicrobeamManipulationRef.append(value)
    def insert_MicrobeamManipulationRef_at(self, index, value): self.MicrobeamManipulationRef.insert(index, value)
    def replace_MicrobeamManipulationRef_at(self, index, value): self.MicrobeamManipulationRef[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType(self, value):
        # Validate type DescriptionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ImageID(self, value):
        # Validate type ImageID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ImageID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ImageID_patterns_, ))
    validate_ImageID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Image:\\S+)|(Image:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.AcquiredDate is not None or
            self.ExperimenterRef is not None or
            self.Description is not None or
            self.ExperimentRef is not None or
            self.GroupRef is not None or
            self.DatasetRef or
            self.InstrumentRef is not None or
            self.ObjectiveSettings is not None or
            self.ImagingEnvironment is not None or
            self.StageLabel is not None or
            self.Pixels is not None or
            self.ROIRef or
            self.MicrobeamManipulationRef or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Image', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.AcquiredDate is not None:
            AcquiredDate_ = self.AcquiredDate
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}AcquiredDate').text = self.gds_format_datetime(AcquiredDate_)
        if self.ExperimenterRef is not None:
            ExperimenterRef_ = self.ExperimenterRef
            ExperimenterRef_.to_etree(element, name_='ExperimenterRef', mapping_=mapping_)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if self.ExperimentRef is not None:
            ExperimentRef_ = self.ExperimentRef
            ExperimentRef_.to_etree(element, name_='ExperimentRef', mapping_=mapping_)
        if self.GroupRef is not None:
            GroupRef_ = self.GroupRef
            GroupRef_.to_etree(element, name_='GroupRef', mapping_=mapping_)
        for DatasetRef_ in self.DatasetRef:
            DatasetRef_.to_etree(element, name_='DatasetRef', mapping_=mapping_)
        if self.InstrumentRef is not None:
            InstrumentRef_ = self.InstrumentRef
            InstrumentRef_.to_etree(element, name_='InstrumentRef', mapping_=mapping_)
        if self.ObjectiveSettings is not None:
            ObjectiveSettings_ = self.ObjectiveSettings
            ObjectiveSettings_.to_etree(element, name_='ObjectiveSettings', mapping_=mapping_)
        if self.ImagingEnvironment is not None:
            ImagingEnvironment_ = self.ImagingEnvironment
            ImagingEnvironment_.to_etree(element, name_='ImagingEnvironment', mapping_=mapping_)
        if self.StageLabel is not None:
            StageLabel_ = self.StageLabel
            StageLabel_.to_etree(element, name_='StageLabel', mapping_=mapping_)
        if self.Pixels is not None:
            Pixels_ = self.Pixels
            Pixels_.to_etree(element, name_='Pixels', mapping_=mapping_)
        for ROIRef_ in self.ROIRef:
            ROIRef_.to_etree(element, name_='ROIRef', mapping_=mapping_)
        for MicrobeamManipulationRef_ in self.MicrobeamManipulationRef:
            MicrobeamManipulationRef_.to_etree(element, name_='MicrobeamManipulationRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ImageID(self.ID)    # validate type ImageID
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AcquiredDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.AcquiredDate = dval_
        elif nodeName_ == 'ExperimenterRef':
            obj_ = ExperimenterRef.factory()
            obj_.build(child_)
            self.ExperimenterRef = obj_
            obj_.original_tagname_ = 'ExperimenterRef'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType(self.Description)    # validate type DescriptionType
        elif nodeName_ == 'ExperimentRef':
            obj_ = ExperimentRef.factory()
            obj_.build(child_)
            self.ExperimentRef = obj_
            obj_.original_tagname_ = 'ExperimentRef'
        elif nodeName_ == 'GroupRef':
            obj_ = GroupRef.factory()
            obj_.build(child_)
            self.GroupRef = obj_
            obj_.original_tagname_ = 'GroupRef'
        elif nodeName_ == 'DatasetRef':
            obj_ = DatasetRef.factory()
            obj_.build(child_)
            self.DatasetRef.append(obj_)
            obj_.original_tagname_ = 'DatasetRef'
        elif nodeName_ == 'InstrumentRef':
            obj_ = InstrumentRef.factory()
            obj_.build(child_)
            self.InstrumentRef = obj_
            obj_.original_tagname_ = 'InstrumentRef'
        elif nodeName_ == 'ObjectiveSettings':
            obj_ = ObjectiveSettings.factory()
            obj_.build(child_)
            self.ObjectiveSettings = obj_
            obj_.original_tagname_ = 'ObjectiveSettings'
        elif nodeName_ == 'ImagingEnvironment':
            obj_ = ImagingEnvironment.factory()
            obj_.build(child_)
            self.ImagingEnvironment = obj_
            obj_.original_tagname_ = 'ImagingEnvironment'
        elif nodeName_ == 'StageLabel':
            obj_ = StageLabel.factory()
            obj_.build(child_)
            self.StageLabel = obj_
            obj_.original_tagname_ = 'StageLabel'
        elif nodeName_ == 'Pixels':
            obj_ = Pixels.factory()
            obj_.build(child_)
            self.Pixels = obj_
            obj_.original_tagname_ = 'Pixels'
        elif nodeName_ == 'ROIRef':
            obj_ = ROIRef.factory()
            obj_.build(child_)
            self.ROIRef.append(obj_)
            obj_.original_tagname_ = 'ROIRef'
        elif nodeName_ == 'MicrobeamManipulationRef':
            obj_ = MicrobeamManipulationRef.factory()
            obj_.build(child_)
            self.MicrobeamManipulationRef.append(obj_)
            obj_.original_tagname_ = 'MicrobeamManipulationRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Image


class Pixels(GeneratedsSuper):
    """The Image will be unreadable if any of the required Pixel attributes
    are missing. The Pixels themselves are stored within the file
    compressed by plane, and encoded in Base64. The Pixels element
    must contain a list of BinData, each containing a single plane
    of pixels. These Pixels elements, when read in document order,
    must produce a 5-D pixel array of the size specified in this
    element, and in the dimension order specified by
    'DimensionOrder'. The order in which the individual planes of
    data are interleaved. The variable type used to represent each
    pixel in the image. Dimensional size of pixel data array
    [units:none]Dimensional size of pixel data array
    [units:none]Dimensional size of pixel data array
    [units:none]Dimensional size of pixel data array
    [units:none]Dimensional size of pixel data array
    [units:none]Physical size of a pixel in microns[um].Physical
    size of a pixel in microns[um].Physical size of a pixel in
    microns[um]. TimeIncrement is used for time series that have a
    global timing specification instead of per-timepoint timing
    info. For example in a video stream. The unit is seconds[s]."""
    subclass = None
    superclass = None
    def __init__(self, SizeT=None, DimensionOrder=None, TimeIncrement=None, PhysicalSizeY=None, PhysicalSizeX=None, PhysicalSizeZ=None, SizeX=None, SizeY=None, SizeZ=None, SizeC=None, Type=None, ID=None, Channel=None, BinData=None, TiffData=None, MetadataOnly=None, Plane=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.SizeT = _cast(None, SizeT)
        self.DimensionOrder = _cast(None, DimensionOrder)
        self.TimeIncrement = _cast(float, TimeIncrement)
        self.PhysicalSizeY = _cast(float, PhysicalSizeY)
        self.PhysicalSizeX = _cast(float, PhysicalSizeX)
        self.PhysicalSizeZ = _cast(float, PhysicalSizeZ)
        self.SizeX = _cast(None, SizeX)
        self.SizeY = _cast(None, SizeY)
        self.SizeZ = _cast(None, SizeZ)
        self.SizeC = _cast(None, SizeC)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        if Channel is None:
            self.Channel = []
        else:
            self.Channel = Channel
        if BinData is None:
            self.BinData = []
        else:
            self.BinData = BinData
        if TiffData is None:
            self.TiffData = []
        else:
            self.TiffData = TiffData
        self.MetadataOnly = MetadataOnly
        if Plane is None:
            self.Plane = []
        else:
            self.Plane = Plane
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Pixels.subclass:
            return Pixels.subclass(*args_, **kwargs_)
        else:
            return Pixels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Channel(self): return self.Channel
    def set_Channel(self, Channel): self.Channel = Channel
    def add_Channel(self, value): self.Channel.append(value)
    def insert_Channel_at(self, index, value): self.Channel.insert(index, value)
    def replace_Channel_at(self, index, value): self.Channel[index] = value
    def get_BinData(self): return self.BinData
    def set_BinData(self, BinData): self.BinData = BinData
    def add_BinData(self, value): self.BinData.append(value)
    def insert_BinData_at(self, index, value): self.BinData.insert(index, value)
    def replace_BinData_at(self, index, value): self.BinData[index] = value
    def get_TiffData(self): return self.TiffData
    def set_TiffData(self, TiffData): self.TiffData = TiffData
    def add_TiffData(self, value): self.TiffData.append(value)
    def insert_TiffData_at(self, index, value): self.TiffData.insert(index, value)
    def replace_TiffData_at(self, index, value): self.TiffData[index] = value
    def get_MetadataOnly(self): return self.MetadataOnly
    def set_MetadataOnly(self, MetadataOnly): self.MetadataOnly = MetadataOnly
    def get_Plane(self): return self.Plane
    def set_Plane(self, Plane): self.Plane = Plane
    def add_Plane(self, value): self.Plane.append(value)
    def insert_Plane_at(self, index, value): self.Plane.insert(index, value)
    def replace_Plane_at(self, index, value): self.Plane[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_SizeT(self): return self.SizeT
    def set_SizeT(self, SizeT): self.SizeT = SizeT
    def get_DimensionOrder(self): return self.DimensionOrder
    def set_DimensionOrder(self, DimensionOrder): self.DimensionOrder = DimensionOrder
    def get_TimeIncrement(self): return self.TimeIncrement
    def set_TimeIncrement(self, TimeIncrement): self.TimeIncrement = TimeIncrement
    def get_PhysicalSizeY(self): return self.PhysicalSizeY
    def set_PhysicalSizeY(self, PhysicalSizeY): self.PhysicalSizeY = PhysicalSizeY
    def get_PhysicalSizeX(self): return self.PhysicalSizeX
    def set_PhysicalSizeX(self, PhysicalSizeX): self.PhysicalSizeX = PhysicalSizeX
    def get_PhysicalSizeZ(self): return self.PhysicalSizeZ
    def set_PhysicalSizeZ(self, PhysicalSizeZ): self.PhysicalSizeZ = PhysicalSizeZ
    def get_SizeX(self): return self.SizeX
    def set_SizeX(self, SizeX): self.SizeX = SizeX
    def get_SizeY(self): return self.SizeY
    def set_SizeY(self, SizeY): self.SizeY = SizeY
    def get_SizeZ(self): return self.SizeZ
    def set_SizeZ(self, SizeZ): self.SizeZ = SizeZ
    def get_SizeC(self): return self.SizeC
    def set_SizeC(self, SizeC): self.SizeC = SizeC
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_PixelType(self, value):
        # Validate type PixelType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['int8', 'int16', 'int32', 'uint8', 'uint16', 'uint32', 'float', 'bit', 'double', 'complex', 'double-complex']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PixelType' % {"value" : value.encode("utf-8")} )
    def validate_PixelsID(self, value):
        # Validate type PixelsID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PixelsID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PixelsID_patterns_, ))
    validate_PixelsID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Pixels:\\S+)|(Pixels:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Channel or
            self.BinData or
            self.TiffData or
            self.MetadataOnly is not None or
            self.Plane or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Pixels', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.SizeT is not None:
            element.set('SizeT', self.SizeT)
        if self.DimensionOrder is not None:
            element.set('DimensionOrder', self.gds_format_string(self.DimensionOrder))
        if self.TimeIncrement is not None:
            element.set('TimeIncrement', self.gds_format_float(self.TimeIncrement))
        if self.PhysicalSizeY is not None:
            element.set('PhysicalSizeY', self.gds_format_float(self.PhysicalSizeY))
        if self.PhysicalSizeX is not None:
            element.set('PhysicalSizeX', self.gds_format_float(self.PhysicalSizeX))
        if self.PhysicalSizeZ is not None:
            element.set('PhysicalSizeZ', self.gds_format_float(self.PhysicalSizeZ))
        if self.SizeX is not None:
            element.set('SizeX', self.SizeX)
        if self.SizeY is not None:
            element.set('SizeY', self.SizeY)
        if self.SizeZ is not None:
            element.set('SizeZ', self.SizeZ)
        if self.SizeC is not None:
            element.set('SizeC', self.SizeC)
        if self.Type is not None:
            element.set('Type', self.Type)
        if self.ID is not None:
            element.set('ID', self.ID)
        for Channel_ in self.Channel:
            Channel_.to_etree(element, name_='Channel', mapping_=mapping_)
        for BinData_ in self.BinData:
            BinData_.to_etree(element, name_='BinData', mapping_=mapping_)
        for TiffData_ in self.TiffData:
            TiffData_.to_etree(element, name_='TiffData', mapping_=mapping_)
        if self.MetadataOnly is not None:
            MetadataOnly_ = self.MetadataOnly
            MetadataOnly_.to_etree(element, name_='MetadataOnly', mapping_=mapping_)
        for Plane_ in self.Plane:
            Plane_.to_etree(element, name_='Plane', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SizeT', node)
        if value is not None and 'SizeT' not in already_processed:
            already_processed.add('SizeT')
            try:
                self.SizeT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeT)    # validate type PositiveInt
        value = find_attr_value_('DimensionOrder', node)
        if value is not None and 'DimensionOrder' not in already_processed:
            already_processed.add('DimensionOrder')
            self.DimensionOrder = value
        value = find_attr_value_('TimeIncrement', node)
        if value is not None and 'TimeIncrement' not in already_processed:
            already_processed.add('TimeIncrement')
            try:
                self.TimeIncrement = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (TimeIncrement): %s' % exp)
        value = find_attr_value_('PhysicalSizeY', node)
        if value is not None and 'PhysicalSizeY' not in already_processed:
            already_processed.add('PhysicalSizeY')
            try:
                self.PhysicalSizeY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PhysicalSizeY): %s' % exp)
        value = find_attr_value_('PhysicalSizeX', node)
        if value is not None and 'PhysicalSizeX' not in already_processed:
            already_processed.add('PhysicalSizeX')
            try:
                self.PhysicalSizeX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PhysicalSizeX): %s' % exp)
        value = find_attr_value_('PhysicalSizeZ', node)
        if value is not None and 'PhysicalSizeZ' not in already_processed:
            already_processed.add('PhysicalSizeZ')
            try:
                self.PhysicalSizeZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PhysicalSizeZ): %s' % exp)
        value = find_attr_value_('SizeX', node)
        if value is not None and 'SizeX' not in already_processed:
            already_processed.add('SizeX')
            try:
                self.SizeX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeX)    # validate type PositiveInt
        value = find_attr_value_('SizeY', node)
        if value is not None and 'SizeY' not in already_processed:
            already_processed.add('SizeY')
            try:
                self.SizeY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeY)    # validate type PositiveInt
        value = find_attr_value_('SizeZ', node)
        if value is not None and 'SizeZ' not in already_processed:
            already_processed.add('SizeZ')
            try:
                self.SizeZ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeZ)    # validate type PositiveInt
        value = find_attr_value_('SizeC', node)
        if value is not None and 'SizeC' not in already_processed:
            already_processed.add('SizeC')
            try:
                self.SizeC = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeC)    # validate type PositiveInt
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_PixelType(self.Type)    # validate type PixelType
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PixelsID(self.ID)    # validate type PixelsID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Channel':
            obj_ = Channel.factory()
            obj_.build(child_)
            self.Channel.append(obj_)
            obj_.original_tagname_ = 'Channel'
        elif nodeName_ == 'BinData':
            obj_ = BinData.factory()
            obj_.build(child_)
            self.BinData.append(obj_)
            obj_.original_tagname_ = 'BinData'
        elif nodeName_ == 'TiffData':
            obj_ = TiffData.factory()
            obj_.build(child_)
            self.TiffData.append(obj_)
            obj_.original_tagname_ = 'TiffData'
        elif nodeName_ == 'MetadataOnly':
            obj_ = MetadataOnly.factory()
            obj_.build(child_)
            self.MetadataOnly = obj_
            obj_.original_tagname_ = 'MetadataOnly'
        elif nodeName_ == 'Plane':
            obj_ = Plane.factory()
            obj_.build(child_)
            self.Plane.append(obj_)
            obj_.original_tagname_ = 'Plane'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Pixels


class Plane(GeneratedsSuper):
    """The Plane object holds microscope stage and image timing data for a
    given channel/z-section/timepoint. This optional element is a
    hash of the plane's image data. It is a choice between all the
    support hash types. Currently the only method supported is SHA1.
    The Z-section this plane is for. [units:none] This is numbered
    from 0. The timepoint this plane is for. [units:none] This is
    numbered from 0. The channel this plane is for. [units:none]
    This is numbered from 0. Units are seconds since the beginning
    of the experiment [s] Units are seconds [s] The X position of
    the stage. [units are in the microscope reference frame] The Y
    position of the stage. [units are in the microscope reference
    frame] The Z position of the stage. [units are in the microscope
    reference frame]"""
    subclass = None
    superclass = None
    def __init__(self, ExposureTime=None, PositionZ=None, PositionX=None, PositionY=None, DeltaT=None, TheC=None, TheZ=None, TheT=None, HashSHA1=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.ExposureTime = _cast(float, ExposureTime)
        self.PositionZ = _cast(float, PositionZ)
        self.PositionX = _cast(float, PositionX)
        self.PositionY = _cast(float, PositionY)
        self.DeltaT = _cast(float, DeltaT)
        self.TheC = _cast(None, TheC)
        self.TheZ = _cast(None, TheZ)
        self.TheT = _cast(None, TheT)
        self.HashSHA1 = HashSHA1
        self.validate_Hex40(self.HashSHA1)
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Plane.subclass:
            return Plane.subclass(*args_, **kwargs_)
        else:
            return Plane(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HashSHA1(self): return self.HashSHA1
    def set_HashSHA1(self, HashSHA1): self.HashSHA1 = HashSHA1
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_ExposureTime(self): return self.ExposureTime
    def set_ExposureTime(self, ExposureTime): self.ExposureTime = ExposureTime
    def get_PositionZ(self): return self.PositionZ
    def set_PositionZ(self, PositionZ): self.PositionZ = PositionZ
    def get_PositionX(self): return self.PositionX
    def set_PositionX(self, PositionX): self.PositionX = PositionX
    def get_PositionY(self): return self.PositionY
    def set_PositionY(self, PositionY): self.PositionY = PositionY
    def get_DeltaT(self): return self.DeltaT
    def set_DeltaT(self, DeltaT): self.DeltaT = DeltaT
    def get_TheC(self): return self.TheC
    def set_TheC(self, TheC): self.TheC = TheC
    def get_TheZ(self): return self.TheZ
    def set_TheZ(self, TheZ): self.TheZ = TheZ
    def get_TheT(self): return self.TheT
    def set_TheT(self, TheT): self.TheT = TheT
    def validate_Hex40(self, value):
        # Validate type Hex40, a restriction on xsd:hexBinary.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 20:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Hex40' % {"value" : value} )
    def validate_NonNegativeInt(self, value):
        # Validate type NonNegativeInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeInt' % {"value" : value} )
    def hasContent_(self):
        if (
            self.HashSHA1 is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Plane', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.ExposureTime is not None:
            element.set('ExposureTime', self.gds_format_float(self.ExposureTime))
        if self.PositionZ is not None:
            element.set('PositionZ', self.gds_format_float(self.PositionZ))
        if self.PositionX is not None:
            element.set('PositionX', self.gds_format_float(self.PositionX))
        if self.PositionY is not None:
            element.set('PositionY', self.gds_format_float(self.PositionY))
        if self.DeltaT is not None:
            element.set('DeltaT', self.gds_format_float(self.DeltaT))
        if self.TheC is not None:
            element.set('TheC', self.TheC)
        if self.TheZ is not None:
            element.set('TheZ', self.TheZ)
        if self.TheT is not None:
            element.set('TheT', self.TheT)
        if self.HashSHA1 is not None:
            HashSHA1_ = self.HashSHA1
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}HashSHA1').text = self.gds_format_string(HashSHA1_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ExposureTime', node)
        if value is not None and 'ExposureTime' not in already_processed:
            already_processed.add('ExposureTime')
            try:
                self.ExposureTime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ExposureTime): %s' % exp)
        value = find_attr_value_('PositionZ', node)
        if value is not None and 'PositionZ' not in already_processed:
            already_processed.add('PositionZ')
            try:
                self.PositionZ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionZ): %s' % exp)
        value = find_attr_value_('PositionX', node)
        if value is not None and 'PositionX' not in already_processed:
            already_processed.add('PositionX')
            try:
                self.PositionX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionX): %s' % exp)
        value = find_attr_value_('PositionY', node)
        if value is not None and 'PositionY' not in already_processed:
            already_processed.add('PositionY')
            try:
                self.PositionY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionY): %s' % exp)
        value = find_attr_value_('DeltaT', node)
        if value is not None and 'DeltaT' not in already_processed:
            already_processed.add('DeltaT')
            try:
                self.DeltaT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (DeltaT): %s' % exp)
        value = find_attr_value_('TheC', node)
        if value is not None and 'TheC' not in already_processed:
            already_processed.add('TheC')
            try:
                self.TheC = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.TheC)    # validate type NonNegativeInt
        value = find_attr_value_('TheZ', node)
        if value is not None and 'TheZ' not in already_processed:
            already_processed.add('TheZ')
            try:
                self.TheZ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.TheZ)    # validate type NonNegativeInt
        value = find_attr_value_('TheT', node)
        if value is not None and 'TheT' not in already_processed:
            already_processed.add('TheT')
            try:
                self.TheT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.TheT)    # validate type NonNegativeInt
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HashSHA1':
            HashSHA1_ = child_.text
            HashSHA1_ = self.gds_validate_string(HashSHA1_, node, 'HashSHA1')
            self.HashSHA1 = HashSHA1_
            self.validate_Hex40(self.HashSHA1)    # validate type Hex40
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Plane


class Channel(GeneratedsSuper):
    """There must be one per channel in the Image, even for a single-plane
    image. And information about how each of them was acquired is
    stored in the various optional *Ref elements. Each Logical
    Channel is composed of one or more ChannelComponents. For
    example, an entire spectrum in an FTIR experiment may be stored
    in a single Logical Channel with each discrete wavenumber of the
    spectrum constituting a ChannelComponent of the FTIR Logical
    Channel. An RGB image where the Red, Green and Blue components
    do not reflect discrete probes but are instead the output of a
    color camera would be treated similarly - one Logical channel
    with three ChannelComponents in this case. The total number of
    ChannelComponents for a set of pixels must equal SizeC. The
    IlluminationType attribute is a string enumeration which may be
    set to 'Transmitted', 'Epifluorescence', 'Oblique', or
    'NonLinear'. The PhotometricInterpretation attribute is used to
    describe how to display a multi-component channel. This
    attribute may be set to: 'monochrome', 'RGB', 'ARGB', 'CMYK',
    'HSV'. The default for single-component channels is
    'monochrome'. The user interface logic for labeling a given
    channel for the user should use the first existing attribute in
    the following sequence: Name -> Fluor -> EmissionWavelength ->
    ChannelComponent/Index. A name for the channel that is suitable
    be presented to the user. The number of samples the detector
    takes to form each pixel value. The SamplesPerPixel attribute is
    the number of channel components in the logical channel.
    [units:none] The method of illumination used to capture the
    channel. The optional PinholeSize attribute allows specifying
    adjustable pin hole diameters for confocal microscopes (units
    microns[um]). AcquisitionMode describes the type of microscopy
    performed for each channel ContrastMethod describes the
    technique used to achieve contrast for each channel Excitation
    wavelength of excitation for a particular channel, in
    nanometres[nm]. Emission wavelength of excitation for a
    particular channel, in nanometres[nm]. The Fluor attribute is
    used for fluorescence images. This is the name of the
    fluorophore used to produce this channel [plain text string] The
    NDfilter attribute is used to specify the combined effect of any
    neutral density filters used. [units optical density expressed
    as a PercentFraction] The PockelCellSetting used for this
    channel. This is the amount the polarization of the beam is
    rotated by. [units:none] A color used render this channel -
    encoded as RGBA The default value "-2147483648" is #FFFFFFFF so
    solid white (it is a signed 32 bit value)"""
    subclass = None
    superclass = None
    def __init__(self, PinholeSize=None, Name=None, AcquisitionMode=None, Color=-2147483648, ContrastMethod=None, ExcitationWavelength=None, IlluminationType=None, Fluor=None, PockelCellSetting=None, EmissionWavelength=None, NDFilter=None, ID=None, SamplesPerPixel=None, LightSourceSettings=None, OTFRef=None, DetectorSettings=None, FilterSetRef=None, AnnotationRef=None, LightPath=None):
        self.original_tagname_ = None
        self.PinholeSize = _cast(float, PinholeSize)
        self.Name = _cast(None, Name)
        self.AcquisitionMode = _cast(None, AcquisitionMode)
        self.Color = _cast(int, Color)
        self.ContrastMethod = _cast(None, ContrastMethod)
        self.ExcitationWavelength = _cast(None, ExcitationWavelength)
        self.IlluminationType = _cast(None, IlluminationType)
        self.Fluor = _cast(None, Fluor)
        self.PockelCellSetting = _cast(int, PockelCellSetting)
        self.EmissionWavelength = _cast(None, EmissionWavelength)
        self.NDFilter = _cast(float, NDFilter)
        self.ID = _cast(None, ID)
        self.SamplesPerPixel = _cast(None, SamplesPerPixel)
        self.LightSourceSettings = LightSourceSettings
        self.OTFRef = OTFRef
        self.DetectorSettings = DetectorSettings
        self.FilterSetRef = FilterSetRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
        self.LightPath = LightPath
    def factory(*args_, **kwargs_):
        if Channel.subclass:
            return Channel.subclass(*args_, **kwargs_)
        else:
            return Channel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LightSourceSettings(self): return self.LightSourceSettings
    def set_LightSourceSettings(self, LightSourceSettings): self.LightSourceSettings = LightSourceSettings
    def get_OTFRef(self): return self.OTFRef
    def set_OTFRef(self, OTFRef): self.OTFRef = OTFRef
    def get_DetectorSettings(self): return self.DetectorSettings
    def set_DetectorSettings(self, DetectorSettings): self.DetectorSettings = DetectorSettings
    def get_FilterSetRef(self): return self.FilterSetRef
    def set_FilterSetRef(self, FilterSetRef): self.FilterSetRef = FilterSetRef
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_LightPath(self): return self.LightPath
    def set_LightPath(self, LightPath): self.LightPath = LightPath
    def get_PinholeSize(self): return self.PinholeSize
    def set_PinholeSize(self, PinholeSize): self.PinholeSize = PinholeSize
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_AcquisitionMode(self): return self.AcquisitionMode
    def set_AcquisitionMode(self, AcquisitionMode): self.AcquisitionMode = AcquisitionMode
    def get_Color(self): return self.Color
    def set_Color(self, Color): self.Color = Color
    def get_ContrastMethod(self): return self.ContrastMethod
    def set_ContrastMethod(self, ContrastMethod): self.ContrastMethod = ContrastMethod
    def get_ExcitationWavelength(self): return self.ExcitationWavelength
    def set_ExcitationWavelength(self, ExcitationWavelength): self.ExcitationWavelength = ExcitationWavelength
    def get_IlluminationType(self): return self.IlluminationType
    def set_IlluminationType(self, IlluminationType): self.IlluminationType = IlluminationType
    def get_Fluor(self): return self.Fluor
    def set_Fluor(self, Fluor): self.Fluor = Fluor
    def get_PockelCellSetting(self): return self.PockelCellSetting
    def set_PockelCellSetting(self, PockelCellSetting): self.PockelCellSetting = PockelCellSetting
    def get_EmissionWavelength(self): return self.EmissionWavelength
    def set_EmissionWavelength(self, EmissionWavelength): self.EmissionWavelength = EmissionWavelength
    def get_NDFilter(self): return self.NDFilter
    def set_NDFilter(self, NDFilter): self.NDFilter = NDFilter
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SamplesPerPixel(self): return self.SamplesPerPixel
    def set_SamplesPerPixel(self, SamplesPerPixel): self.SamplesPerPixel = SamplesPerPixel
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_ChannelID(self, value):
        # Validate type ChannelID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChannelID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ChannelID_patterns_, ))
    validate_ChannelID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Channel:\\S+)|(Channel:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.LightSourceSettings is not None or
            self.OTFRef is not None or
            self.DetectorSettings is not None or
            self.FilterSetRef is not None or
            self.AnnotationRef or
            self.LightPath is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Channel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.PinholeSize is not None:
            element.set('PinholeSize', self.gds_format_float(self.PinholeSize))
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.AcquisitionMode is not None:
            element.set('AcquisitionMode', self.gds_format_string(self.AcquisitionMode))
        if self.Color is not None:
            element.set('Color', self.gds_format_integer(self.Color))
        if self.ContrastMethod is not None:
            element.set('ContrastMethod', self.gds_format_string(self.ContrastMethod))
        if self.ExcitationWavelength is not None:
            element.set('ExcitationWavelength', self.ExcitationWavelength)
        if self.IlluminationType is not None:
            element.set('IlluminationType', self.gds_format_string(self.IlluminationType))
        if self.Fluor is not None:
            element.set('Fluor', self.gds_format_string(self.Fluor))
        if self.PockelCellSetting is not None:
            element.set('PockelCellSetting', self.gds_format_integer(self.PockelCellSetting))
        if self.EmissionWavelength is not None:
            element.set('EmissionWavelength', self.EmissionWavelength)
        if self.NDFilter is not None:
            element.set('NDFilter', self.gds_format_float(self.NDFilter))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.SamplesPerPixel is not None:
            element.set('SamplesPerPixel', self.SamplesPerPixel)
        if self.LightSourceSettings is not None:
            LightSourceSettings_ = self.LightSourceSettings
            LightSourceSettings_.to_etree(element, name_='LightSourceSettings', mapping_=mapping_)
        if self.OTFRef is not None:
            OTFRef_ = self.OTFRef
            OTFRef_.to_etree(element, name_='OTFRef', mapping_=mapping_)
        if self.DetectorSettings is not None:
            DetectorSettings_ = self.DetectorSettings
            DetectorSettings_.to_etree(element, name_='DetectorSettings', mapping_=mapping_)
        if self.FilterSetRef is not None:
            FilterSetRef_ = self.FilterSetRef
            FilterSetRef_.to_etree(element, name_='FilterSetRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if self.LightPath is not None:
            LightPath_ = self.LightPath
            LightPath_.to_etree(element, name_='LightPath', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PinholeSize', node)
        if value is not None and 'PinholeSize' not in already_processed:
            already_processed.add('PinholeSize')
            try:
                self.PinholeSize = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PinholeSize): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('AcquisitionMode', node)
        if value is not None and 'AcquisitionMode' not in already_processed:
            already_processed.add('AcquisitionMode')
            self.AcquisitionMode = value
        value = find_attr_value_('Color', node)
        if value is not None and 'Color' not in already_processed:
            already_processed.add('Color')
            try:
                self.Color = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ContrastMethod', node)
        if value is not None and 'ContrastMethod' not in already_processed:
            already_processed.add('ContrastMethod')
            self.ContrastMethod = value
        value = find_attr_value_('ExcitationWavelength', node)
        if value is not None and 'ExcitationWavelength' not in already_processed:
            already_processed.add('ExcitationWavelength')
            try:
                self.ExcitationWavelength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.ExcitationWavelength)    # validate type PositiveInt
        value = find_attr_value_('IlluminationType', node)
        if value is not None and 'IlluminationType' not in already_processed:
            already_processed.add('IlluminationType')
            self.IlluminationType = value
        value = find_attr_value_('Fluor', node)
        if value is not None and 'Fluor' not in already_processed:
            already_processed.add('Fluor')
            self.Fluor = value
        value = find_attr_value_('PockelCellSetting', node)
        if value is not None and 'PockelCellSetting' not in already_processed:
            already_processed.add('PockelCellSetting')
            try:
                self.PockelCellSetting = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('EmissionWavelength', node)
        if value is not None and 'EmissionWavelength' not in already_processed:
            already_processed.add('EmissionWavelength')
            try:
                self.EmissionWavelength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.EmissionWavelength)    # validate type PositiveInt
        value = find_attr_value_('NDFilter', node)
        if value is not None and 'NDFilter' not in already_processed:
            already_processed.add('NDFilter')
            try:
                self.NDFilter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (NDFilter): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ChannelID(self.ID)    # validate type ChannelID
        value = find_attr_value_('SamplesPerPixel', node)
        if value is not None and 'SamplesPerPixel' not in already_processed:
            already_processed.add('SamplesPerPixel')
            try:
                self.SamplesPerPixel = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SamplesPerPixel)    # validate type PositiveInt
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LightSourceSettings':
            obj_ = LightSourceSettings.factory()
            obj_.build(child_)
            self.LightSourceSettings = obj_
            obj_.original_tagname_ = 'LightSourceSettings'
        elif nodeName_ == 'OTFRef':
            obj_ = OTFRef.factory()
            obj_.build(child_)
            self.OTFRef = obj_
            obj_.original_tagname_ = 'OTFRef'
        elif nodeName_ == 'DetectorSettings':
            obj_ = DetectorSettings.factory()
            obj_.build(child_)
            self.DetectorSettings = obj_
            obj_.original_tagname_ = 'DetectorSettings'
        elif nodeName_ == 'FilterSetRef':
            obj_ = FilterSetRef.factory()
            obj_.build(child_)
            self.FilterSetRef = obj_
            obj_.original_tagname_ = 'FilterSetRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
        elif nodeName_ == 'LightPath':
            obj_ = LightPath.factory()
            obj_.build(child_)
            self.LightPath = obj_
            obj_.original_tagname_ = 'LightPath'
# end class Channel


class MetadataOnly(GeneratedsSuper):
    """This place holder means there is on pixel data in this file."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if MetadataOnly.subclass:
            return MetadataOnly.subclass(*args_, **kwargs_)
        else:
            return MetadataOnly(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MetadataOnly', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MetadataOnly


class TiffData(GeneratedsSuper):
    """This described the location of the pixel data in a tiff file. Gives
    the IFD(s) for which this element is applicable. Indexed from 0.
    Default is 0 (the first IFD). [units:none] Gives the Z position
    of the image plane at the specified IFD. Indexed from 0. Default
    is 0 (the first Z position). [units:none] Gives the T position
    of the image plane at the specified IFD. Indexed from 0. Default
    is 0 (the first T position). [units:none] Gives the C position
    of the image plane at the specified IFD. Indexed from 0. Default
    is 0 (the first C position). [units:none] Gives the number of
    IFDs affected. Dimension order of IFDs is given by the enclosing
    Pixels element's DimensionOrder attribute. Default is the number
    of IFDs in the TIFF file, unless an IFD is specified, in which
    case the default is 1. [units:none]"""
    subclass = None
    superclass = None
    def __init__(self, IFD='0', PlaneCount=None, FirstZ='0', FirstC='0', FirstT='0', UUID=None):
        self.original_tagname_ = None
        self.IFD = _cast(None, IFD)
        self.PlaneCount = _cast(None, PlaneCount)
        self.FirstZ = _cast(None, FirstZ)
        self.FirstC = _cast(None, FirstC)
        self.FirstT = _cast(None, FirstT)
        self.UUID = UUID
    def factory(*args_, **kwargs_):
        if TiffData.subclass:
            return TiffData.subclass(*args_, **kwargs_)
        else:
            return TiffData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def get_IFD(self): return self.IFD
    def set_IFD(self, IFD): self.IFD = IFD
    def get_PlaneCount(self): return self.PlaneCount
    def set_PlaneCount(self, PlaneCount): self.PlaneCount = PlaneCount
    def get_FirstZ(self): return self.FirstZ
    def set_FirstZ(self, FirstZ): self.FirstZ = FirstZ
    def get_FirstC(self): return self.FirstC
    def set_FirstC(self, FirstC): self.FirstC = FirstC
    def get_FirstT(self): return self.FirstT
    def set_FirstT(self, FirstT): self.FirstT = FirstT
    def validate_NonNegativeInt(self, value):
        # Validate type NonNegativeInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeInt' % {"value" : value} )
    def hasContent_(self):
        if (
            self.UUID is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TiffData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.IFD is not None:
            element.set('IFD', self.IFD)
        if self.PlaneCount is not None:
            element.set('PlaneCount', self.PlaneCount)
        if self.FirstZ is not None:
            element.set('FirstZ', self.FirstZ)
        if self.FirstC is not None:
            element.set('FirstC', self.FirstC)
        if self.FirstT is not None:
            element.set('FirstT', self.FirstT)
        if self.UUID is not None:
            UUID_ = self.UUID
            UUID_.to_etree(element, name_='UUID', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IFD', node)
        if value is not None and 'IFD' not in already_processed:
            already_processed.add('IFD')
            try:
                self.IFD = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.IFD)    # validate type NonNegativeInt
        value = find_attr_value_('PlaneCount', node)
        if value is not None and 'PlaneCount' not in already_processed:
            already_processed.add('PlaneCount')
            try:
                self.PlaneCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.PlaneCount)    # validate type NonNegativeInt
        value = find_attr_value_('FirstZ', node)
        if value is not None and 'FirstZ' not in already_processed:
            already_processed.add('FirstZ')
            try:
                self.FirstZ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.FirstZ)    # validate type NonNegativeInt
        value = find_attr_value_('FirstC', node)
        if value is not None and 'FirstC' not in already_processed:
            already_processed.add('FirstC')
            try:
                self.FirstC = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.FirstC)    # validate type NonNegativeInt
        value = find_attr_value_('FirstT', node)
        if value is not None and 'FirstT' not in already_processed:
            already_processed.add('FirstT')
            try:
                self.FirstT = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.FirstT)    # validate type NonNegativeInt
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UUID':
            obj_ = UUIDType.factory()
            obj_.build(child_)
            self.UUID = obj_
            obj_.original_tagname_ = 'UUID'
# end class TiffData


class StageLabel(GeneratedsSuper):
    """The StageLabel is used to specify a name and position for a stage
    position in the microscope's reference frame. The X position of
    the stage label. [units are in the microscope reference frame]
    The Y position of the stage label. [units are in the microscope
    reference frame] The Z position of the stage label. [units are
    in the microscope reference frame]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, Z=None, Name=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.Z = _cast(float, Z)
        self.Name = _cast(None, Name)
    def factory(*args_, **kwargs_):
        if StageLabel.subclass:
            return StageLabel.subclass(*args_, **kwargs_)
        else:
            return StageLabel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StageLabel', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if self.Z is not None:
            element.set('Z', self.gds_format_float(self.Z))
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
        value = find_attr_value_('Z', node)
        if value is not None and 'Z' not in already_processed:
            already_processed.add('Z')
            try:
                self.Z = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Z): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StageLabel


class MicrobeamManipulation(GeneratedsSuper):
    """Defines a microbeam operation type and the region of the image it
    was applied to. The LightSourceRef element is a reference to a
    LightSource specified in the Instrument element which was used
    for a technique other than illumination for the purpose of
    imaging. For example, a laser used for photobleaching. The type
    of manipulation performed."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, ROIRef=None, ExperimenterRef=None, LightSourceSettings=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        if ROIRef is None:
            self.ROIRef = []
        else:
            self.ROIRef = ROIRef
        self.ExperimenterRef = ExperimenterRef
        if LightSourceSettings is None:
            self.LightSourceSettings = []
        else:
            self.LightSourceSettings = LightSourceSettings
    def factory(*args_, **kwargs_):
        if MicrobeamManipulation.subclass:
            return MicrobeamManipulation.subclass(*args_, **kwargs_)
        else:
            return MicrobeamManipulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ROIRef(self): return self.ROIRef
    def set_ROIRef(self, ROIRef): self.ROIRef = ROIRef
    def add_ROIRef(self, value): self.ROIRef.append(value)
    def insert_ROIRef_at(self, index, value): self.ROIRef.insert(index, value)
    def replace_ROIRef_at(self, index, value): self.ROIRef[index] = value
    def get_ExperimenterRef(self): return self.ExperimenterRef
    def set_ExperimenterRef(self, ExperimenterRef): self.ExperimenterRef = ExperimenterRef
    def get_LightSourceSettings(self): return self.LightSourceSettings
    def set_LightSourceSettings(self, LightSourceSettings): self.LightSourceSettings = LightSourceSettings
    def add_LightSourceSettings(self, value): self.LightSourceSettings.append(value)
    def insert_LightSourceSettings_at(self, index, value): self.LightSourceSettings.insert(index, value)
    def replace_LightSourceSettings_at(self, index, value): self.LightSourceSettings[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_MicrobeamManipulationID(self, value):
        # Validate type MicrobeamManipulationID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_MicrobeamManipulationID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MicrobeamManipulationID_patterns_, ))
    validate_MicrobeamManipulationID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:MicrobeamManipulation:\\S+)|(MicrobeamManipulation:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.ROIRef or
            self.ExperimenterRef is not None or
            self.LightSourceSettings
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MicrobeamManipulation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.ID is not None:
            element.set('ID', self.ID)
        for ROIRef_ in self.ROIRef:
            ROIRef_.to_etree(element, name_='ROIRef', mapping_=mapping_)
        if self.ExperimenterRef is not None:
            ExperimenterRef_ = self.ExperimenterRef
            ExperimenterRef_.to_etree(element, name_='ExperimenterRef', mapping_=mapping_)
        for LightSourceSettings_ in self.LightSourceSettings:
            LightSourceSettings_.to_etree(element, name_='LightSourceSettings', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_MicrobeamManipulationID(self.ID)    # validate type MicrobeamManipulationID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ROIRef':
            obj_ = ROIRef.factory()
            obj_.build(child_)
            self.ROIRef.append(obj_)
            obj_.original_tagname_ = 'ROIRef'
        elif nodeName_ == 'ExperimenterRef':
            obj_ = ExperimenterRef.factory()
            obj_.build(child_)
            self.ExperimenterRef = obj_
            obj_.original_tagname_ = 'ExperimenterRef'
        elif nodeName_ == 'LightSourceSettings':
            obj_ = LightSourceSettings.factory()
            obj_.build(child_)
            self.LightSourceSettings.append(obj_)
            obj_.original_tagname_ = 'LightSourceSettings'
# end class MicrobeamManipulation


class Instrument(GeneratedsSuper):
    """This element describes the instrument used to capture the Image. It
    is primarily a container for manufacturer's model and catalog
    numbers for the Microscope, LightSource, Detector, Objective and
    Filters components. Additionally, one or more OTF elements may
    be specified, describing the optical transfer function under
    different conditions. The Objective element contains the
    additional elements LensNA and Magnification. The Filters
    element can be composed either of separate excitation, emission
    filters and a dichroic mirror or a single filter set. Within the
    Image itself, a reference is made to this one Filter element.
    The OTF element contains an optical transfer function. The same
    OTF can be used for all wavelengths, or there may be one per
    wavelength. There may be multiple light sources, detectors,
    objectives and filters on a microscope. Each of these has their
    own ID attribute, which can be referred to from Channel. It is
    understood that the light path configuration can be different
    for each channel, but cannot be different for each timepoint or
    each plane of an XYZ stack."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Microscope=None, LightSource=None, Detector=None, Objective=None, FilterSet=None, Filter=None, Dichroic=None, OTF=None):
        self.original_tagname_ = None
        self.ID = _cast(None, ID)
        self.Microscope = Microscope
        if LightSource is None:
            self.LightSource = []
        else:
            self.LightSource = LightSource
        if Detector is None:
            self.Detector = []
        else:
            self.Detector = Detector
        if Objective is None:
            self.Objective = []
        else:
            self.Objective = Objective
        if FilterSet is None:
            self.FilterSet = []
        else:
            self.FilterSet = FilterSet
        if Filter is None:
            self.Filter = []
        else:
            self.Filter = Filter
        if Dichroic is None:
            self.Dichroic = []
        else:
            self.Dichroic = Dichroic
        if OTF is None:
            self.OTF = []
        else:
            self.OTF = OTF
    def factory(*args_, **kwargs_):
        if Instrument.subclass:
            return Instrument.subclass(*args_, **kwargs_)
        else:
            return Instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Microscope(self): return self.Microscope
    def set_Microscope(self, Microscope): self.Microscope = Microscope
    def get_LightSource(self): return self.LightSource
    def set_LightSource(self, LightSource): self.LightSource = LightSource
    def add_LightSource(self, value): self.LightSource.append(value)
    def insert_LightSource_at(self, index, value): self.LightSource.insert(index, value)
    def replace_LightSource_at(self, index, value): self.LightSource[index] = value
    def get_Detector(self): return self.Detector
    def set_Detector(self, Detector): self.Detector = Detector
    def add_Detector(self, value): self.Detector.append(value)
    def insert_Detector_at(self, index, value): self.Detector.insert(index, value)
    def replace_Detector_at(self, index, value): self.Detector[index] = value
    def get_Objective(self): return self.Objective
    def set_Objective(self, Objective): self.Objective = Objective
    def add_Objective(self, value): self.Objective.append(value)
    def insert_Objective_at(self, index, value): self.Objective.insert(index, value)
    def replace_Objective_at(self, index, value): self.Objective[index] = value
    def get_FilterSet(self): return self.FilterSet
    def set_FilterSet(self, FilterSet): self.FilterSet = FilterSet
    def add_FilterSet(self, value): self.FilterSet.append(value)
    def insert_FilterSet_at(self, index, value): self.FilterSet.insert(index, value)
    def replace_FilterSet_at(self, index, value): self.FilterSet[index] = value
    def get_Filter(self): return self.Filter
    def set_Filter(self, Filter): self.Filter = Filter
    def add_Filter(self, value): self.Filter.append(value)
    def insert_Filter_at(self, index, value): self.Filter.insert(index, value)
    def replace_Filter_at(self, index, value): self.Filter[index] = value
    def get_Dichroic(self): return self.Dichroic
    def set_Dichroic(self, Dichroic): self.Dichroic = Dichroic
    def add_Dichroic(self, value): self.Dichroic.append(value)
    def insert_Dichroic_at(self, index, value): self.Dichroic.insert(index, value)
    def replace_Dichroic_at(self, index, value): self.Dichroic[index] = value
    def get_OTF(self): return self.OTF
    def set_OTF(self, OTF): self.OTF = OTF
    def add_OTF(self, value): self.OTF.append(value)
    def insert_OTF_at(self, index, value): self.OTF.insert(index, value)
    def replace_OTF_at(self, index, value): self.OTF[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_InstrumentID(self, value):
        # Validate type InstrumentID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_InstrumentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_InstrumentID_patterns_, ))
    validate_InstrumentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Instrument:\\S+)|(Instrument:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Microscope is not None or
            self.LightSource or
            self.Detector or
            self.Objective or
            self.FilterSet or
            self.Filter or
            self.Dichroic or
            self.OTF
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Instrument', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Microscope is not None:
            Microscope_ = self.Microscope
            Microscope_.to_etree(element, name_='Microscope', mapping_=mapping_)
        for LightSource_ in self.LightSource:
            LightSource_.to_etree(element, name_='LightSource', mapping_=mapping_)
        for Detector_ in self.Detector:
            Detector_.to_etree(element, name_='Detector', mapping_=mapping_)
        for Objective_ in self.Objective:
            Objective_.to_etree(element, name_='Objective', mapping_=mapping_)
        for FilterSet_ in self.FilterSet:
            FilterSet_.to_etree(element, name_='FilterSet', mapping_=mapping_)
        for Filter_ in self.Filter:
            Filter_.to_etree(element, name_='Filter', mapping_=mapping_)
        for Dichroic_ in self.Dichroic:
            Dichroic_.to_etree(element, name_='Dichroic', mapping_=mapping_)
        for OTF_ in self.OTF:
            OTF_.to_etree(element, name_='OTF', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_InstrumentID(self.ID)    # validate type InstrumentID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Microscope':
            obj_ = Microscope.factory()
            obj_.build(child_)
            self.Microscope = obj_
            obj_.original_tagname_ = 'Microscope'
        elif nodeName_ == 'LightSource':
            obj_ = LightSource.factory()
            obj_.build(child_)
            self.LightSource.append(obj_)
            obj_.original_tagname_ = 'LightSource'
        elif nodeName_ == 'Detector':
            obj_ = Detector.factory()
            obj_.build(child_)
            self.Detector.append(obj_)
            obj_.original_tagname_ = 'Detector'
        elif nodeName_ == 'Objective':
            obj_ = Objective.factory()
            obj_.build(child_)
            self.Objective.append(obj_)
            obj_.original_tagname_ = 'Objective'
        elif nodeName_ == 'FilterSet':
            obj_ = FilterSet.factory()
            obj_.build(child_)
            self.FilterSet.append(obj_)
            obj_.original_tagname_ = 'FilterSet'
        elif nodeName_ == 'Filter':
            obj_ = Filter.factory()
            obj_.build(child_)
            self.Filter.append(obj_)
            obj_.original_tagname_ = 'Filter'
        elif nodeName_ == 'Dichroic':
            obj_ = Dichroic.factory()
            obj_.build(child_)
            self.Dichroic.append(obj_)
            obj_.original_tagname_ = 'Dichroic'
        elif nodeName_ == 'OTF':
            obj_ = OTF.factory()
            obj_.build(child_)
            self.OTF.append(obj_)
            obj_.original_tagname_ = 'OTF'
# end class Instrument


class OTF(GeneratedsSuper):
    """The optical transfer function. FilterSetRef refers to the set of
    filters used in computing the OTF. This element must contain a
    BinData element containing the Base64-encoded OTF. These work
    the same way as they do for the Data element within Image. The
    variable type used to specify the size of pixel the OTF is for
    designed for. The OpticalAxisAveraged is a boolean specifying
    whether or not optical axis averaging was done. [flag] The width
    of the OTF. [units:none] The height of the OTF. [units:none]"""
    subclass = None
    superclass = None
    def __init__(self, SizeX=None, SizeY=None, Type=None, ID=None, OpticalAxisAveraged=None, ObjectiveSettings=None, FilterSetRef=None, BinaryFile=None):
        self.original_tagname_ = None
        self.SizeX = _cast(None, SizeX)
        self.SizeY = _cast(None, SizeY)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.OpticalAxisAveraged = _cast(bool, OpticalAxisAveraged)
        self.ObjectiveSettings = ObjectiveSettings
        self.FilterSetRef = FilterSetRef
        self.BinaryFile = BinaryFile
    def factory(*args_, **kwargs_):
        if OTF.subclass:
            return OTF.subclass(*args_, **kwargs_)
        else:
            return OTF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ObjectiveSettings(self): return self.ObjectiveSettings
    def set_ObjectiveSettings(self, ObjectiveSettings): self.ObjectiveSettings = ObjectiveSettings
    def get_FilterSetRef(self): return self.FilterSetRef
    def set_FilterSetRef(self, FilterSetRef): self.FilterSetRef = FilterSetRef
    def get_BinaryFile(self): return self.BinaryFile
    def set_BinaryFile(self, BinaryFile): self.BinaryFile = BinaryFile
    def get_SizeX(self): return self.SizeX
    def set_SizeX(self, SizeX): self.SizeX = SizeX
    def get_SizeY(self): return self.SizeY
    def set_SizeY(self, SizeY): self.SizeY = SizeY
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_OpticalAxisAveraged(self): return self.OpticalAxisAveraged
    def set_OpticalAxisAveraged(self, OpticalAxisAveraged): self.OpticalAxisAveraged = OpticalAxisAveraged
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_PixelType(self, value):
        # Validate type PixelType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['int8', 'int16', 'int32', 'uint8', 'uint16', 'uint32', 'float', 'bit', 'double', 'complex', 'double-complex']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PixelType' % {"value" : value.encode("utf-8")} )
    def validate_OTFID(self, value):
        # Validate type OTFID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_OTFID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OTFID_patterns_, ))
    validate_OTFID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:OTF:\\S+)|(OTF:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.ObjectiveSettings is not None or
            self.FilterSetRef is not None or
            self.BinaryFile is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OTF', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.SizeX is not None:
            element.set('SizeX', self.SizeX)
        if self.SizeY is not None:
            element.set('SizeY', self.SizeY)
        if self.Type is not None:
            element.set('Type', self.Type)
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.OpticalAxisAveraged is not None:
            element.set('OpticalAxisAveraged', self.gds_format_boolean(self.OpticalAxisAveraged))
        if self.ObjectiveSettings is not None:
            ObjectiveSettings_ = self.ObjectiveSettings
            ObjectiveSettings_.to_etree(element, name_='ObjectiveSettings', mapping_=mapping_)
        if self.FilterSetRef is not None:
            FilterSetRef_ = self.FilterSetRef
            FilterSetRef_.to_etree(element, name_='FilterSetRef', mapping_=mapping_)
        if self.BinaryFile is not None:
            BinaryFile_ = self.BinaryFile
            BinaryFile_.to_etree(element, name_='BinaryFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SizeX', node)
        if value is not None and 'SizeX' not in already_processed:
            already_processed.add('SizeX')
            try:
                self.SizeX = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeX)    # validate type PositiveInt
        value = find_attr_value_('SizeY', node)
        if value is not None and 'SizeY' not in already_processed:
            already_processed.add('SizeY')
            try:
                self.SizeY = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.SizeY)    # validate type PositiveInt
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
            self.validate_PixelType(self.Type)    # validate type PixelType
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_OTFID(self.ID)    # validate type OTFID
        value = find_attr_value_('OpticalAxisAveraged', node)
        if value is not None and 'OpticalAxisAveraged' not in already_processed:
            already_processed.add('OpticalAxisAveraged')
            if value in ('true', '1'):
                self.OpticalAxisAveraged = True
            elif value in ('false', '0'):
                self.OpticalAxisAveraged = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ObjectiveSettings':
            obj_ = ObjectiveSettings.factory()
            obj_.build(child_)
            self.ObjectiveSettings = obj_
            obj_.original_tagname_ = 'ObjectiveSettings'
        elif nodeName_ == 'FilterSetRef':
            obj_ = FilterSetRef.factory()
            obj_.build(child_)
            self.FilterSetRef = obj_
            obj_.original_tagname_ = 'FilterSetRef'
        elif nodeName_ == 'BinaryFile':
            obj_ = BinaryFile.factory()
            obj_.build(child_)
            self.BinaryFile = obj_
            obj_.original_tagname_ = 'BinaryFile'
# end class OTF


class ImagingEnvironment(GeneratedsSuper):
    """This describes the environment that the biological sample was in
    during the experiment. The Temperature is in Celsius[C].
    AirPressure is in millibars[mbar]. Humidity around the sample
    [units:none] A fraction, as a value from 0.0 to 1.0. Carbon
    Dioxide concentration around the sample [units:none] A fraction,
    as a value from 0.0 to 1.0."""
    subclass = None
    superclass = None
    def __init__(self, CO2Percent=None, Temperature=None, AirPressure=None, Humidity=None):
        self.original_tagname_ = None
        self.CO2Percent = _cast(None, CO2Percent)
        self.Temperature = _cast(float, Temperature)
        self.AirPressure = _cast(float, AirPressure)
        self.Humidity = _cast(None, Humidity)
    def factory(*args_, **kwargs_):
        if ImagingEnvironment.subclass:
            return ImagingEnvironment.subclass(*args_, **kwargs_)
        else:
            return ImagingEnvironment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CO2Percent(self): return self.CO2Percent
    def set_CO2Percent(self, CO2Percent): self.CO2Percent = CO2Percent
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def get_AirPressure(self): return self.AirPressure
    def set_AirPressure(self, AirPressure): self.AirPressure = AirPressure
    def get_Humidity(self): return self.Humidity
    def set_Humidity(self, Humidity): self.Humidity = Humidity
    def validate_PercentFraction(self, value):
        # Validate type PercentFraction, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PercentFraction' % {"value" : value} )
            if value > 1.0:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PercentFraction' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ImagingEnvironment', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.CO2Percent is not None:
            element.set('CO2Percent', self.CO2Percent)
        if self.Temperature is not None:
            element.set('Temperature', self.gds_format_float(self.Temperature))
        if self.AirPressure is not None:
            element.set('AirPressure', self.gds_format_float(self.AirPressure))
        if self.Humidity is not None:
            element.set('Humidity', self.Humidity)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CO2Percent', node)
        if value is not None and 'CO2Percent' not in already_processed:
            already_processed.add('CO2Percent')
            try:
                self.CO2Percent = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CO2Percent): %s' % exp)
            self.validate_PercentFraction(self.CO2Percent)    # validate type PercentFraction
        value = find_attr_value_('Temperature', node)
        if value is not None and 'Temperature' not in already_processed:
            already_processed.add('Temperature')
            try:
                self.Temperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Temperature): %s' % exp)
        value = find_attr_value_('AirPressure', node)
        if value is not None and 'AirPressure' not in already_processed:
            already_processed.add('AirPressure')
            try:
                self.AirPressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (AirPressure): %s' % exp)
        value = find_attr_value_('Humidity', node)
        if value is not None and 'Humidity' not in already_processed:
            already_processed.add('Humidity')
            try:
                self.Humidity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Humidity): %s' % exp)
            self.validate_PercentFraction(self.Humidity)    # validate type PercentFraction
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ImagingEnvironment


class Project(GeneratedsSuper):
    """The Project ID is required. Datasets can be grouped into projects
    using a many-to-many relationship. A Dataset may belong to one
    or more Projects by including one or more ProjectRef elements
    which refer to Project IDs. Projects do not directly contain
    images - only by virtue of containing datasets, which themselves
    contain images."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, ID=None, Description=None, ExperimenterRef=None, GroupRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.ID = _cast(None, ID)
        self.Description = Description
        self.validate_DescriptionType1(self.Description)
        self.ExperimenterRef = ExperimenterRef
        self.GroupRef = GroupRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Project.subclass:
            return Project.subclass(*args_, **kwargs_)
        else:
            return Project(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ExperimenterRef(self): return self.ExperimenterRef
    def set_ExperimenterRef(self, ExperimenterRef): self.ExperimenterRef = ExperimenterRef
    def get_GroupRef(self): return self.GroupRef
    def set_GroupRef(self, GroupRef): self.GroupRef = GroupRef
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DescriptionType1(self, value):
        # Validate type DescriptionType1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ProjectID(self, value):
        # Validate type ProjectID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ProjectID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ProjectID_patterns_, ))
    validate_ProjectID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Project:\\S+)|(Project:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ExperimenterRef is not None or
            self.GroupRef is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Project', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if self.ExperimenterRef is not None:
            ExperimenterRef_ = self.ExperimenterRef
            ExperimenterRef_.to_etree(element, name_='ExperimenterRef', mapping_=mapping_)
        if self.GroupRef is not None:
            GroupRef_ = self.GroupRef
            GroupRef_.to_etree(element, name_='GroupRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ProjectID(self.ID)    # validate type ProjectID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType1(self.Description)    # validate type DescriptionType1
        elif nodeName_ == 'ExperimenterRef':
            obj_ = ExperimenterRef.factory()
            obj_.build(child_)
            self.ExperimenterRef = obj_
            obj_.original_tagname_ = 'ExperimenterRef'
        elif nodeName_ == 'GroupRef':
            obj_ = GroupRef.factory()
            obj_.build(child_)
            self.GroupRef = obj_
            obj_.original_tagname_ = 'GroupRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Project


class Group(GeneratedsSuper):
    """The Group ID is required. Contact information should be specified
    for the leader of the group and a contact person. The Leader
    and/or Contact are themselves experimenters."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, ID=None, Description=None, Leader=None, Contact=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.ID = _cast(None, ID)
        self.Description = Description
        self.validate_DescriptionType2(self.Description)
        self.Leader = Leader
        self.Contact = Contact
    def factory(*args_, **kwargs_):
        if Group.subclass:
            return Group.subclass(*args_, **kwargs_)
        else:
            return Group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Leader(self): return self.Leader
    def set_Leader(self, Leader): self.Leader = Leader
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DescriptionType2(self, value):
        # Validate type DescriptionType2, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_GroupID(self, value):
        # Validate type GroupID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_GroupID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_GroupID_patterns_, ))
    validate_GroupID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Group:\\S+)|(Group:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Leader is not None or
            self.Contact is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Group', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if self.Leader is not None:
            Leader_ = self.Leader
            Leader_.to_etree(element, name_='Leader', mapping_=mapping_)
        if self.Contact is not None:
            Contact_ = self.Contact
            Contact_.to_etree(element, name_='Contact', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_GroupID(self.ID)    # validate type GroupID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType2(self.Description)    # validate type DescriptionType2
        elif nodeName_ == 'Leader':
            obj_ = Leader.factory()
            obj_.build(child_)
            self.Leader = obj_
            obj_.original_tagname_ = 'Leader'
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
# end class Group


class Dataset(GeneratedsSuper):
    """An element specifying a collection of images that are always
    processed together. Images can belong to more than one Dataset,
    and a Dataset may contain more than one Image. Images contain
    one or more DatasetRef elements to specify what datasets they
    belong to. Once a Dataset has been processed in any way, its
    collection of images cannot be altered. The ExperimenterRef and
    GroupRef elements specify the person and group this Dataset
    belongs to. Projects may contain one or more Datasets, and
    Datasets may belong to one or more Projects. This relationship
    is specified by listing ProjectRef elements within the Dataset
    element. A name for the dataset that is suitable be presented to
    the user."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, ID=None, Description=None, ExperimenterRef=None, GroupRef=None, ProjectRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.ID = _cast(None, ID)
        self.Description = Description
        self.validate_DescriptionType3(self.Description)
        self.ExperimenterRef = ExperimenterRef
        self.GroupRef = GroupRef
        if ProjectRef is None:
            self.ProjectRef = []
        else:
            self.ProjectRef = ProjectRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Dataset.subclass:
            return Dataset.subclass(*args_, **kwargs_)
        else:
            return Dataset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ExperimenterRef(self): return self.ExperimenterRef
    def set_ExperimenterRef(self, ExperimenterRef): self.ExperimenterRef = ExperimenterRef
    def get_GroupRef(self): return self.GroupRef
    def set_GroupRef(self, GroupRef): self.GroupRef = GroupRef
    def get_ProjectRef(self): return self.ProjectRef
    def set_ProjectRef(self, ProjectRef): self.ProjectRef = ProjectRef
    def add_ProjectRef(self, value): self.ProjectRef.append(value)
    def insert_ProjectRef_at(self, index, value): self.ProjectRef.insert(index, value)
    def replace_ProjectRef_at(self, index, value): self.ProjectRef[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DescriptionType3(self, value):
        # Validate type DescriptionType3, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DatasetID(self, value):
        # Validate type DatasetID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DatasetID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DatasetID_patterns_, ))
    validate_DatasetID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Dataset:\\S+)|(Dataset:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ExperimenterRef is not None or
            self.GroupRef is not None or
            self.ProjectRef or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Dataset', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if self.ExperimenterRef is not None:
            ExperimenterRef_ = self.ExperimenterRef
            ExperimenterRef_.to_etree(element, name_='ExperimenterRef', mapping_=mapping_)
        if self.GroupRef is not None:
            GroupRef_ = self.GroupRef
            GroupRef_.to_etree(element, name_='GroupRef', mapping_=mapping_)
        for ProjectRef_ in self.ProjectRef:
            ProjectRef_.to_etree(element, name_='ProjectRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DatasetID(self.ID)    # validate type DatasetID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType3(self.Description)    # validate type DescriptionType3
        elif nodeName_ == 'ExperimenterRef':
            obj_ = ExperimenterRef.factory()
            obj_.build(child_)
            self.ExperimenterRef = obj_
            obj_.original_tagname_ = 'ExperimenterRef'
        elif nodeName_ == 'GroupRef':
            obj_ = GroupRef.factory()
            obj_.build(child_)
            self.GroupRef = obj_
            obj_.original_tagname_ = 'GroupRef'
        elif nodeName_ == 'ProjectRef':
            obj_ = ProjectRef.factory()
            obj_.build(child_)
            self.ProjectRef.append(obj_)
            obj_.original_tagname_ = 'ProjectRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Dataset


class Experiment(GeneratedsSuper):
    """This element describes the type of experiment. The required Type
    attribute must contain one or more entries from the following
    list: FP FRET Time-lapse 4-D+ Screen Immunocytochemistry FISH
    Electrophysiology Ion-Imaging Colocalization PGI/Documentation
    FRAP Photoablation Optical-Trapping Photoactivation
    Fluorescence-Lifetime Spectral-Imaging Other FP refers to
    fluorescent proteins, PGI/Docuemntation is not a 'data' image.
    The optional Description element may contain free text to
    further describe the experiment. A term to describe the type of
    experiment."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, ID=None, Description=None, ExperimenterRef=None, MicrobeamManipulation=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.Description = Description
        self.validate_DescriptionType4(self.Description)
        self.ExperimenterRef = ExperimenterRef
        if MicrobeamManipulation is None:
            self.MicrobeamManipulation = []
        else:
            self.MicrobeamManipulation = MicrobeamManipulation
    def factory(*args_, **kwargs_):
        if Experiment.subclass:
            return Experiment.subclass(*args_, **kwargs_)
        else:
            return Experiment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ExperimenterRef(self): return self.ExperimenterRef
    def set_ExperimenterRef(self, ExperimenterRef): self.ExperimenterRef = ExperimenterRef
    def get_MicrobeamManipulation(self): return self.MicrobeamManipulation
    def set_MicrobeamManipulation(self, MicrobeamManipulation): self.MicrobeamManipulation = MicrobeamManipulation
    def add_MicrobeamManipulation(self, value): self.MicrobeamManipulation.append(value)
    def insert_MicrobeamManipulation_at(self, index, value): self.MicrobeamManipulation.insert(index, value)
    def replace_MicrobeamManipulation_at(self, index, value): self.MicrobeamManipulation[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DescriptionType4(self, value):
        # Validate type DescriptionType4, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ExperimentID(self, value):
        # Validate type ExperimentID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimentID_patterns_, ))
    validate_ExperimentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experiment:\\S+)|(Experiment:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ExperimenterRef is not None or
            self.MicrobeamManipulation
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Experiment', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if self.ExperimenterRef is not None:
            ExperimenterRef_ = self.ExperimenterRef
            ExperimenterRef_.to_etree(element, name_='ExperimenterRef', mapping_=mapping_)
        for MicrobeamManipulation_ in self.MicrobeamManipulation:
            MicrobeamManipulation_.to_etree(element, name_='MicrobeamManipulation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimentID(self.ID)    # validate type ExperimentID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType4(self.Description)    # validate type DescriptionType4
        elif nodeName_ == 'ExperimenterRef':
            obj_ = ExperimenterRef.factory()
            obj_.build(child_)
            self.ExperimenterRef = obj_
            obj_.original_tagname_ = 'ExperimenterRef'
        elif nodeName_ == 'MicrobeamManipulation':
            obj_ = MicrobeamManipulation.factory()
            obj_.build(child_)
            self.MicrobeamManipulation.append(obj_)
            obj_.original_tagname_ = 'MicrobeamManipulation'
# end class Experiment


class Experimenter(GeneratedsSuper):
    """This element describes a person who performed an imaging experiment.
    This person may also be a user of the OME system, in which case
    the UserName element contains their login name. Experimenters
    may belong to one or more groups which are specified using one
    or more GroupRef elements. This is the only required name field.
    [plain text string]First name, sometime called christian name or
    given name or forename. [plain text string]Any other names.
    [plain text string]A person's last name sometimes called surname
    or family name. [plain text string]A person's email address.
    [valid email address as string] A person's Institution The
    organizing structure that people belong to other than groups. A
    university, or company, etc. We do not specify a department
    element, and do not mean for Institution to be used in this way.
    We simply wish to say XXX at YYY. Where YYY has a better chance
    of being tied to a geographically fixed location and of being
    more recognizable than a group of experimenters. [plain text
    string] This is the username of the experimenter (in a 'unix' or
    'database' sense). [plain text string]"""
    subclass = None
    superclass = None
    def __init__(self, UserName=None, DisplayName=None, FirstName=None, MiddleName=None, LastName=None, Email=None, Institution=None, ID=None, GroupRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.UserName = _cast(None, UserName)
        self.DisplayName = _cast(None, DisplayName)
        self.FirstName = _cast(None, FirstName)
        self.MiddleName = _cast(None, MiddleName)
        self.LastName = _cast(None, LastName)
        self.Email = _cast(None, Email)
        self.Institution = _cast(None, Institution)
        self.ID = _cast(None, ID)
        if GroupRef is None:
            self.GroupRef = []
        else:
            self.GroupRef = GroupRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Experimenter.subclass:
            return Experimenter.subclass(*args_, **kwargs_)
        else:
            return Experimenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GroupRef(self): return self.GroupRef
    def set_GroupRef(self, GroupRef): self.GroupRef = GroupRef
    def add_GroupRef(self, value): self.GroupRef.append(value)
    def insert_GroupRef_at(self, index, value): self.GroupRef.insert(index, value)
    def replace_GroupRef_at(self, index, value): self.GroupRef[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_UserName(self): return self.UserName
    def set_UserName(self, UserName): self.UserName = UserName
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_MiddleName(self): return self.MiddleName
    def set_MiddleName(self, MiddleName): self.MiddleName = MiddleName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def get_Institution(self): return self.Institution
    def set_Institution(self, Institution): self.Institution = Institution
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ExperimenterID(self, value):
        # Validate type ExperimenterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimenterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimenterID_patterns_, ))
    validate_ExperimenterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experimenter:\\S+)|(Experimenter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.GroupRef or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Experimenter', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.UserName is not None:
            element.set('UserName', self.gds_format_string(self.UserName))
        if self.DisplayName is not None:
            element.set('DisplayName', self.gds_format_string(self.DisplayName))
        if self.FirstName is not None:
            element.set('FirstName', self.gds_format_string(self.FirstName))
        if self.MiddleName is not None:
            element.set('MiddleName', self.gds_format_string(self.MiddleName))
        if self.LastName is not None:
            element.set('LastName', self.gds_format_string(self.LastName))
        if self.Email is not None:
            element.set('Email', self.gds_format_string(self.Email))
        if self.Institution is not None:
            element.set('Institution', self.gds_format_string(self.Institution))
        if self.ID is not None:
            element.set('ID', self.ID)
        for GroupRef_ in self.GroupRef:
            GroupRef_.to_etree(element, name_='GroupRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UserName', node)
        if value is not None and 'UserName' not in already_processed:
            already_processed.add('UserName')
            self.UserName = value
        value = find_attr_value_('DisplayName', node)
        if value is not None and 'DisplayName' not in already_processed:
            already_processed.add('DisplayName')
            self.DisplayName = value
        value = find_attr_value_('FirstName', node)
        if value is not None and 'FirstName' not in already_processed:
            already_processed.add('FirstName')
            self.FirstName = value
        value = find_attr_value_('MiddleName', node)
        if value is not None and 'MiddleName' not in already_processed:
            already_processed.add('MiddleName')
            self.MiddleName = value
        value = find_attr_value_('LastName', node)
        if value is not None and 'LastName' not in already_processed:
            already_processed.add('LastName')
            self.LastName = value
        value = find_attr_value_('Email', node)
        if value is not None and 'Email' not in already_processed:
            already_processed.add('Email')
            self.Email = value
        value = find_attr_value_('Institution', node)
        if value is not None and 'Institution' not in already_processed:
            already_processed.add('Institution')
            self.Institution = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimenterID(self.ID)    # validate type ExperimenterID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GroupRef':
            obj_ = GroupRef.factory()
            obj_.build(child_)
            self.GroupRef.append(obj_)
            obj_.original_tagname_ = 'GroupRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Experimenter


class ManufacturerSpec(GeneratedsSuper):
    """This is the base from which many microscope components are extended.
    E.g Objective, Filter etc. Provides attributes for recording
    common properties of these components such as Manufacturer name,
    Model etc, all of which are optional. The manufacturer of the
    component. [plain text string] The Model of the component.
    [plain text string] The serial number of the component. [plain
    text string] The lot number of the component. [plain text
    string]"""
    subclass = None
    superclass = None
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None):
        self.original_tagname_ = None
        self.LotNumber = _cast(None, LotNumber)
        self.Model = _cast(None, Model)
        self.SerialNumber = _cast(None, SerialNumber)
        self.Manufacturer = _cast(None, Manufacturer)
    def factory(*args_, **kwargs_):
        if ManufacturerSpec.subclass:
            return ManufacturerSpec.subclass(*args_, **kwargs_)
        else:
            return ManufacturerSpec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LotNumber(self): return self.LotNumber
    def set_LotNumber(self, LotNumber): self.LotNumber = LotNumber
    def get_Model(self): return self.Model
    def set_Model(self, Model): self.Model = Model
    def get_SerialNumber(self): return self.SerialNumber
    def set_SerialNumber(self, SerialNumber): self.SerialNumber = SerialNumber
    def get_Manufacturer(self): return self.Manufacturer
    def set_Manufacturer(self, Manufacturer): self.Manufacturer = Manufacturer
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ManufacturerSpec', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.LotNumber is not None:
            element.set('LotNumber', self.gds_format_string(self.LotNumber))
        if self.Model is not None:
            element.set('Model', self.gds_format_string(self.Model))
        if self.SerialNumber is not None:
            element.set('SerialNumber', self.gds_format_string(self.SerialNumber))
        if self.Manufacturer is not None:
            element.set('Manufacturer', self.gds_format_string(self.Manufacturer))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LotNumber', node)
        if value is not None and 'LotNumber' not in already_processed:
            already_processed.add('LotNumber')
            self.LotNumber = value
        value = find_attr_value_('Model', node)
        if value is not None and 'Model' not in already_processed:
            already_processed.add('Model')
            self.Model = value
        value = find_attr_value_('SerialNumber', node)
        if value is not None and 'SerialNumber' not in already_processed:
            already_processed.add('SerialNumber')
            self.SerialNumber = value
        value = find_attr_value_('Manufacturer', node)
        if value is not None and 'Manufacturer' not in already_processed:
            already_processed.add('Manufacturer')
            self.Manufacturer = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ManufacturerSpec


class Objective(ManufacturerSpec):
    """A description of the microscope's objective lens. Required elements
    include the lens numerical aperture, and the magnification, both
    of which a floating point (real) numbers. The values are those
    that are fixed for a particular objective: either because it has
    been manufactured to this specification or the value has been
    measured on this particular objective. Correction: This is the
    type of correction coating applied to this lens. Immersion: This
    is the types of immersion medium the lens is designed to work
    with. It is not the same as 'Medium' in ObjectiveRef (a single
    type) as here Immersion can have compound values like 'Multi'.
    LensNA: The numerical aperture of the lens (as a float)
    NominalMagnification: The specified magnification e.g. x10
    CalibratedMagnification: The measured magnification e.g. x10.3
    WorkingDistance: WorkingDistance of the lens. The Units are
    microns[um]. The correction applied to the lensThe immersion
    medium the lens is designed for The numerical aperture of the
    lens expressed as a floating point (real) number. Expected range
    0.02 - 1.5 [units:none] The magnification of the lens as
    specified by the manufacturer - i.e. '60' is a 60X lens.
    [units:none] The magnification of the lens as measured by a
    calibration process- i.e. '59.987' for a 60X lens. [units:none]
    The working distance of the lens expressed as a floating point
    (real) number. Units are microns[um]. Records whether or not the
    objective was fitted with an Iris. [flag]"""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, Iris=None, WorkingDistance=None, Immersion=None, Correction=None, LensNA=None, NominalMagnification=None, CalibratedMagnification=None, ID=None):
        self.original_tagname_ = None
        super(Objective, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.Iris = _cast(bool, Iris)
        self.WorkingDistance = _cast(float, WorkingDistance)
        self.Immersion = _cast(None, Immersion)
        self.Correction = _cast(None, Correction)
        self.LensNA = _cast(float, LensNA)
        self.NominalMagnification = _cast(None, NominalMagnification)
        self.CalibratedMagnification = _cast(float, CalibratedMagnification)
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if Objective.subclass:
            return Objective.subclass(*args_, **kwargs_)
        else:
            return Objective(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Iris(self): return self.Iris
    def set_Iris(self, Iris): self.Iris = Iris
    def get_WorkingDistance(self): return self.WorkingDistance
    def set_WorkingDistance(self, WorkingDistance): self.WorkingDistance = WorkingDistance
    def get_Immersion(self): return self.Immersion
    def set_Immersion(self, Immersion): self.Immersion = Immersion
    def get_Correction(self): return self.Correction
    def set_Correction(self, Correction): self.Correction = Correction
    def get_LensNA(self): return self.LensNA
    def set_LensNA(self, LensNA): self.LensNA = LensNA
    def get_NominalMagnification(self): return self.NominalMagnification
    def set_NominalMagnification(self, NominalMagnification): self.NominalMagnification = NominalMagnification
    def get_CalibratedMagnification(self): return self.CalibratedMagnification
    def set_CalibratedMagnification(self, CalibratedMagnification): self.CalibratedMagnification = CalibratedMagnification
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_ObjectiveID(self, value):
        # Validate type ObjectiveID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectiveID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ObjectiveID_patterns_, ))
    validate_ObjectiveID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Objective:\\S+)|(Objective:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Objective, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Objective', mapping_=None):
        element = super(Objective, self).to_etree(parent_element, name_, mapping_)
        if self.Iris is not None:
            element.set('Iris', self.gds_format_boolean(self.Iris))
        if self.WorkingDistance is not None:
            element.set('WorkingDistance', self.gds_format_float(self.WorkingDistance))
        if self.Immersion is not None:
            element.set('Immersion', self.gds_format_string(self.Immersion))
        if self.Correction is not None:
            element.set('Correction', self.gds_format_string(self.Correction))
        if self.LensNA is not None:
            element.set('LensNA', self.gds_format_float(self.LensNA))
        if self.NominalMagnification is not None:
            element.set('NominalMagnification', self.NominalMagnification)
        if self.CalibratedMagnification is not None:
            element.set('CalibratedMagnification', self.gds_format_float(self.CalibratedMagnification))
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Iris', node)
        if value is not None and 'Iris' not in already_processed:
            already_processed.add('Iris')
            if value in ('true', '1'):
                self.Iris = True
            elif value in ('false', '0'):
                self.Iris = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('WorkingDistance', node)
        if value is not None and 'WorkingDistance' not in already_processed:
            already_processed.add('WorkingDistance')
            try:
                self.WorkingDistance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WorkingDistance): %s' % exp)
        value = find_attr_value_('Immersion', node)
        if value is not None and 'Immersion' not in already_processed:
            already_processed.add('Immersion')
            self.Immersion = value
        value = find_attr_value_('Correction', node)
        if value is not None and 'Correction' not in already_processed:
            already_processed.add('Correction')
            self.Correction = value
        value = find_attr_value_('LensNA', node)
        if value is not None and 'LensNA' not in already_processed:
            already_processed.add('LensNA')
            try:
                self.LensNA = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LensNA): %s' % exp)
        value = find_attr_value_('NominalMagnification', node)
        if value is not None and 'NominalMagnification' not in already_processed:
            already_processed.add('NominalMagnification')
            try:
                self.NominalMagnification = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.NominalMagnification)    # validate type PositiveInt
        value = find_attr_value_('CalibratedMagnification', node)
        if value is not None and 'CalibratedMagnification' not in already_processed:
            already_processed.add('CalibratedMagnification')
            try:
                self.CalibratedMagnification = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CalibratedMagnification): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ObjectiveID(self.ID)    # validate type ObjectiveID
        super(Objective, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Objective, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Objective


class Detector(ManufacturerSpec):
    """The type of detector used to capture the image. The Detector ID can
    be used as a reference within the Channel element in the Image
    element. The Detector Gain for this detector, as a float.
    [units:none] The Voltage of the detector (e.g. PMT voltage) as a
    float. volts[V] The Detector Offset. [units:none] The Zoom or
    "Confocal Zoom" or "Scan Zoom" for a detector. [units:none] Gain
    applied to the detector signal. This is the electronic gain (as
    apposed to the inherent gain) that is set for the detector.
    [units:none] The Type of detector. E.g. CCD, PMT, EMCCD etc."""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, Zoom=None, AmplificationGain=None, Gain=None, Offset=None, Type=None, ID=None, Voltage=None):
        self.original_tagname_ = None
        super(Detector, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.Zoom = _cast(float, Zoom)
        self.AmplificationGain = _cast(float, AmplificationGain)
        self.Gain = _cast(float, Gain)
        self.Offset = _cast(float, Offset)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.Voltage = _cast(float, Voltage)
    def factory(*args_, **kwargs_):
        if Detector.subclass:
            return Detector.subclass(*args_, **kwargs_)
        else:
            return Detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Zoom(self): return self.Zoom
    def set_Zoom(self, Zoom): self.Zoom = Zoom
    def get_AmplificationGain(self): return self.AmplificationGain
    def set_AmplificationGain(self, AmplificationGain): self.AmplificationGain = AmplificationGain
    def get_Gain(self): return self.Gain
    def set_Gain(self, Gain): self.Gain = Gain
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Voltage(self): return self.Voltage
    def set_Voltage(self, Voltage): self.Voltage = Voltage
    def validate_DetectorID(self, value):
        # Validate type DetectorID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DetectorID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DetectorID_patterns_, ))
    validate_DetectorID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Detector:\\S+)|(Detector:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Detector, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Detector', mapping_=None):
        element = super(Detector, self).to_etree(parent_element, name_, mapping_)
        if self.Zoom is not None:
            element.set('Zoom', self.gds_format_float(self.Zoom))
        if self.AmplificationGain is not None:
            element.set('AmplificationGain', self.gds_format_float(self.AmplificationGain))
        if self.Gain is not None:
            element.set('Gain', self.gds_format_float(self.Gain))
        if self.Offset is not None:
            element.set('Offset', self.gds_format_float(self.Offset))
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Voltage is not None:
            element.set('Voltage', self.gds_format_float(self.Voltage))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Zoom', node)
        if value is not None and 'Zoom' not in already_processed:
            already_processed.add('Zoom')
            try:
                self.Zoom = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Zoom): %s' % exp)
        value = find_attr_value_('AmplificationGain', node)
        if value is not None and 'AmplificationGain' not in already_processed:
            already_processed.add('AmplificationGain')
            try:
                self.AmplificationGain = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (AmplificationGain): %s' % exp)
        value = find_attr_value_('Gain', node)
        if value is not None and 'Gain' not in already_processed:
            already_processed.add('Gain')
            try:
                self.Gain = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Gain): %s' % exp)
        value = find_attr_value_('Offset', node)
        if value is not None and 'Offset' not in already_processed:
            already_processed.add('Offset')
            try:
                self.Offset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Offset): %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DetectorID(self.ID)    # validate type DetectorID
        value = find_attr_value_('Voltage', node)
        if value is not None and 'Voltage' not in already_processed:
            already_processed.add('Voltage')
            try:
                self.Voltage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Voltage): %s' % exp)
        super(Detector, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Detector, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Detector


class FilterSet(ManufacturerSpec):
    """Filter set manufacturer specification"""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, ID=None, ExcitationFilterRef=None, DichroicRef=None, EmissionFilterRef=None):
        self.original_tagname_ = None
        super(FilterSet, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.ID = _cast(None, ID)
        if ExcitationFilterRef is None:
            self.ExcitationFilterRef = []
        else:
            self.ExcitationFilterRef = ExcitationFilterRef
        self.DichroicRef = DichroicRef
        if EmissionFilterRef is None:
            self.EmissionFilterRef = []
        else:
            self.EmissionFilterRef = EmissionFilterRef
    def factory(*args_, **kwargs_):
        if FilterSet.subclass:
            return FilterSet.subclass(*args_, **kwargs_)
        else:
            return FilterSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExcitationFilterRef(self): return self.ExcitationFilterRef
    def set_ExcitationFilterRef(self, ExcitationFilterRef): self.ExcitationFilterRef = ExcitationFilterRef
    def add_ExcitationFilterRef(self, value): self.ExcitationFilterRef.append(value)
    def insert_ExcitationFilterRef_at(self, index, value): self.ExcitationFilterRef.insert(index, value)
    def replace_ExcitationFilterRef_at(self, index, value): self.ExcitationFilterRef[index] = value
    def get_DichroicRef(self): return self.DichroicRef
    def set_DichroicRef(self, DichroicRef): self.DichroicRef = DichroicRef
    def get_EmissionFilterRef(self): return self.EmissionFilterRef
    def set_EmissionFilterRef(self, EmissionFilterRef): self.EmissionFilterRef = EmissionFilterRef
    def add_EmissionFilterRef(self, value): self.EmissionFilterRef.append(value)
    def insert_EmissionFilterRef_at(self, index, value): self.EmissionFilterRef.insert(index, value)
    def replace_EmissionFilterRef_at(self, index, value): self.EmissionFilterRef[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_FilterSetID(self, value):
        # Validate type FilterSetID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_FilterSetID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_FilterSetID_patterns_, ))
    validate_FilterSetID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:FilterSet:\\S+)|(FilterSet:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.ExcitationFilterRef or
            self.DichroicRef is not None or
            self.EmissionFilterRef or
            super(FilterSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FilterSet', mapping_=None):
        element = super(FilterSet, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        for ExcitationFilterRef_ in self.ExcitationFilterRef:
            ExcitationFilterRef_.to_etree(element, name_='ExcitationFilterRef', mapping_=mapping_)
        if self.DichroicRef is not None:
            DichroicRef_ = self.DichroicRef
            DichroicRef_.to_etree(element, name_='DichroicRef', mapping_=mapping_)
        for EmissionFilterRef_ in self.EmissionFilterRef:
            EmissionFilterRef_.to_etree(element, name_='EmissionFilterRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_FilterSetID(self.ID)    # validate type FilterSetID
        super(FilterSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExcitationFilterRef':
            obj_ = FilterRef.factory()
            obj_.build(child_)
            self.ExcitationFilterRef.append(obj_)
            obj_.original_tagname_ = 'ExcitationFilterRef'
        elif nodeName_ == 'DichroicRef':
            obj_ = DichroicRef.factory()
            obj_.build(child_)
            self.DichroicRef = obj_
            obj_.original_tagname_ = 'DichroicRef'
        elif nodeName_ == 'EmissionFilterRef':
            obj_ = FilterRef.factory()
            obj_.build(child_)
            self.EmissionFilterRef.append(obj_)
            obj_.original_tagname_ = 'EmissionFilterRef'
        super(FilterSet, self).buildChildren(child_, node, nodeName_, True)
# end class FilterSet


class Filter(ManufacturerSpec):
    """A filter is either an excitation or emission filters. There should
    be one filter element specified per wavelength in the image. The
    channel number associated with a filter set is specified in
    Channel. It is based on the FilterSpec type, so has the required
    attributes Manufacturer, Model, and LotNumber. It may also
    contain a Type attribute which may be set to 'LongPass',
    'ShortPass', 'BandPass', or 'MultiPass'. It can be associated
    with an optional FilterWheel - Note: this is not the same as a
    FilterSet A filter 'wheel' in OME can refer to any arrangement
    of filters in a filter holder of any shape. It could, for
    example, be a filter slider. [plain text string]"""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, FilterWheel=None, Type=None, ID=None, TransmittanceRange=None):
        self.original_tagname_ = None
        super(Filter, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.FilterWheel = _cast(None, FilterWheel)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.TransmittanceRange = TransmittanceRange
    def factory(*args_, **kwargs_):
        if Filter.subclass:
            return Filter.subclass(*args_, **kwargs_)
        else:
            return Filter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransmittanceRange(self): return self.TransmittanceRange
    def set_TransmittanceRange(self, TransmittanceRange): self.TransmittanceRange = TransmittanceRange
    def get_FilterWheel(self): return self.FilterWheel
    def set_FilterWheel(self, FilterWheel): self.FilterWheel = FilterWheel
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_FilterID(self, value):
        # Validate type FilterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_FilterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_FilterID_patterns_, ))
    validate_FilterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Filter:\\S+)|(Filter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.TransmittanceRange is not None or
            super(Filter, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Filter', mapping_=None):
        element = super(Filter, self).to_etree(parent_element, name_, mapping_)
        if self.FilterWheel is not None:
            element.set('FilterWheel', self.gds_format_string(self.FilterWheel))
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.TransmittanceRange is not None:
            TransmittanceRange_ = self.TransmittanceRange
            TransmittanceRange_.to_etree(element, name_='TransmittanceRange', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FilterWheel', node)
        if value is not None and 'FilterWheel' not in already_processed:
            already_processed.add('FilterWheel')
            self.FilterWheel = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_FilterID(self.ID)    # validate type FilterID
        super(Filter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransmittanceRange':
            obj_ = TransmittanceRange.factory()
            obj_.build(child_)
            self.TransmittanceRange = obj_
            obj_.original_tagname_ = 'TransmittanceRange'
        super(Filter, self).buildChildren(child_, node, nodeName_, True)
# end class Filter


class TransmittanceRange(GeneratedsSuper):
    """This records the range of wavelengths that are transmitted by the
    filter. It also records the maximum amount of light transmitted.
    CutIn is the wavelength below which there is less than 50%
    transmittance for a filter. Units: nanometres[nm]. CutOut is the
    wavelength above which there is less than 50% transmittance for
    a filter. Units: nanometres[nm]. CutInTolerance Units:
    nanometres[nm], CutOutTolerance Units: nanometres[nm], The
    amount of light the filter transmits at a maximum [units:none] A
    fraction, as a value from 0.0 to 1.0."""
    subclass = None
    superclass = None
    def __init__(self, CutIn=None, Transmittance=None, CutOut=None, CutInTolerance=None, CutOutTolerance=None):
        self.original_tagname_ = None
        self.CutIn = _cast(None, CutIn)
        self.Transmittance = _cast(None, Transmittance)
        self.CutOut = _cast(None, CutOut)
        self.CutInTolerance = _cast(None, CutInTolerance)
        self.CutOutTolerance = _cast(None, CutOutTolerance)
    def factory(*args_, **kwargs_):
        if TransmittanceRange.subclass:
            return TransmittanceRange.subclass(*args_, **kwargs_)
        else:
            return TransmittanceRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CutIn(self): return self.CutIn
    def set_CutIn(self, CutIn): self.CutIn = CutIn
    def get_Transmittance(self): return self.Transmittance
    def set_Transmittance(self, Transmittance): self.Transmittance = Transmittance
    def get_CutOut(self): return self.CutOut
    def set_CutOut(self, CutOut): self.CutOut = CutOut
    def get_CutInTolerance(self): return self.CutInTolerance
    def set_CutInTolerance(self, CutInTolerance): self.CutInTolerance = CutInTolerance
    def get_CutOutTolerance(self): return self.CutOutTolerance
    def set_CutOutTolerance(self, CutOutTolerance): self.CutOutTolerance = CutOutTolerance
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_PercentFraction(self, value):
        # Validate type PercentFraction, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PercentFraction' % {"value" : value} )
            if value > 1.0:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PercentFraction' % {"value" : value} )
    def validate_NonNegativeInt(self, value):
        # Validate type NonNegativeInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NonNegativeInt' % {"value" : value} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TransmittanceRange', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.CutIn is not None:
            element.set('CutIn', self.CutIn)
        if self.Transmittance is not None:
            element.set('Transmittance', self.Transmittance)
        if self.CutOut is not None:
            element.set('CutOut', self.CutOut)
        if self.CutInTolerance is not None:
            element.set('CutInTolerance', self.CutInTolerance)
        if self.CutOutTolerance is not None:
            element.set('CutOutTolerance', self.CutOutTolerance)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CutIn', node)
        if value is not None and 'CutIn' not in already_processed:
            already_processed.add('CutIn')
            try:
                self.CutIn = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.CutIn)    # validate type PositiveInt
        value = find_attr_value_('Transmittance', node)
        if value is not None and 'Transmittance' not in already_processed:
            already_processed.add('Transmittance')
            try:
                self.Transmittance = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Transmittance): %s' % exp)
            self.validate_PercentFraction(self.Transmittance)    # validate type PercentFraction
        value = find_attr_value_('CutOut', node)
        if value is not None and 'CutOut' not in already_processed:
            already_processed.add('CutOut')
            try:
                self.CutOut = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.CutOut)    # validate type PositiveInt
        value = find_attr_value_('CutInTolerance', node)
        if value is not None and 'CutInTolerance' not in already_processed:
            already_processed.add('CutInTolerance')
            try:
                self.CutInTolerance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.CutInTolerance)    # validate type NonNegativeInt
        value = find_attr_value_('CutOutTolerance', node)
        if value is not None and 'CutOutTolerance' not in already_processed:
            already_processed.add('CutOutTolerance')
            try:
                self.CutOutTolerance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_NonNegativeInt(self.CutOutTolerance)    # validate type NonNegativeInt
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TransmittanceRange


class Dichroic(ManufacturerSpec):
    """The dichromatic beamsplitter or dichroic mirror used for this filter
    combination."""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, ID=None):
        self.original_tagname_ = None
        super(Dichroic, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if Dichroic.subclass:
            return Dichroic.subclass(*args_, **kwargs_)
        else:
            return Dichroic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DichroicID(self, value):
        # Validate type DichroicID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DichroicID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DichroicID_patterns_, ))
    validate_DichroicID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Dichroic:\\S+)|(Dichroic:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Dichroic, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Dichroic', mapping_=None):
        element = super(Dichroic, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DichroicID(self.ID)    # validate type DichroicID
        super(Dichroic, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Dichroic, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Dichroic


class LightPath(GeneratedsSuper):
    """A description of the light path"""
    subclass = None
    superclass = None
    def __init__(self, ExcitationFilterRef=None, DichroicRef=None, EmissionFilterRef=None):
        self.original_tagname_ = None
        if ExcitationFilterRef is None:
            self.ExcitationFilterRef = []
        else:
            self.ExcitationFilterRef = ExcitationFilterRef
        self.DichroicRef = DichroicRef
        if EmissionFilterRef is None:
            self.EmissionFilterRef = []
        else:
            self.EmissionFilterRef = EmissionFilterRef
    def factory(*args_, **kwargs_):
        if LightPath.subclass:
            return LightPath.subclass(*args_, **kwargs_)
        else:
            return LightPath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExcitationFilterRef(self): return self.ExcitationFilterRef
    def set_ExcitationFilterRef(self, ExcitationFilterRef): self.ExcitationFilterRef = ExcitationFilterRef
    def add_ExcitationFilterRef(self, value): self.ExcitationFilterRef.append(value)
    def insert_ExcitationFilterRef_at(self, index, value): self.ExcitationFilterRef.insert(index, value)
    def replace_ExcitationFilterRef_at(self, index, value): self.ExcitationFilterRef[index] = value
    def get_DichroicRef(self): return self.DichroicRef
    def set_DichroicRef(self, DichroicRef): self.DichroicRef = DichroicRef
    def get_EmissionFilterRef(self): return self.EmissionFilterRef
    def set_EmissionFilterRef(self, EmissionFilterRef): self.EmissionFilterRef = EmissionFilterRef
    def add_EmissionFilterRef(self, value): self.EmissionFilterRef.append(value)
    def insert_EmissionFilterRef_at(self, index, value): self.EmissionFilterRef.insert(index, value)
    def replace_EmissionFilterRef_at(self, index, value): self.EmissionFilterRef[index] = value
    def hasContent_(self):
        if (
            self.ExcitationFilterRef or
            self.DichroicRef is not None or
            self.EmissionFilterRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LightPath', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        for ExcitationFilterRef_ in self.ExcitationFilterRef:
            ExcitationFilterRef_.to_etree(element, name_='ExcitationFilterRef', mapping_=mapping_)
        if self.DichroicRef is not None:
            DichroicRef_ = self.DichroicRef
            DichroicRef_.to_etree(element, name_='DichroicRef', mapping_=mapping_)
        for EmissionFilterRef_ in self.EmissionFilterRef:
            EmissionFilterRef_.to_etree(element, name_='EmissionFilterRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExcitationFilterRef':
            obj_ = FilterRef.factory()
            obj_.build(child_)
            self.ExcitationFilterRef.append(obj_)
            obj_.original_tagname_ = 'ExcitationFilterRef'
        elif nodeName_ == 'DichroicRef':
            obj_ = DichroicRef.factory()
            obj_.build(child_)
            self.DichroicRef = obj_
            obj_.original_tagname_ = 'DichroicRef'
        elif nodeName_ == 'EmissionFilterRef':
            obj_ = FilterRef.factory()
            obj_.build(child_)
            self.EmissionFilterRef.append(obj_)
            obj_.original_tagname_ = 'EmissionFilterRef'
# end class LightPath


class LightSource(ManufacturerSpec):
    """The lightsource for the instrument. An instrument may have several
    light sources. The type of lightsource is specified by one of
    the child-elements which are 'Laser', 'Filament', 'Arc' or
    'LightEmittingDiode'. Each of the light source types has its own
    Type attribute to further differentiate the light source (eg,
    Nd-YAG for Laser or Hg for Arc). A LightSource ID must be
    specified for each light source, and the individual light
    sources can be referred to by their LightSource IDs (eg from
    Channel). The light-source power. units milliwatts[mW]"""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, ID=None, Power=None, Laser=None, Filament=None, Arc=None, LightEmittingDiode=None):
        self.original_tagname_ = None
        super(LightSource, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.ID = _cast(None, ID)
        self.Power = _cast(float, Power)
        self.Laser = Laser
        self.Filament = Filament
        self.Arc = Arc
        self.LightEmittingDiode = LightEmittingDiode
    def factory(*args_, **kwargs_):
        if LightSource.subclass:
            return LightSource.subclass(*args_, **kwargs_)
        else:
            return LightSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Laser(self): return self.Laser
    def set_Laser(self, Laser): self.Laser = Laser
    def get_Filament(self): return self.Filament
    def set_Filament(self, Filament): self.Filament = Filament
    def get_Arc(self): return self.Arc
    def set_Arc(self, Arc): self.Arc = Arc
    def get_LightEmittingDiode(self): return self.LightEmittingDiode
    def set_LightEmittingDiode(self, LightEmittingDiode): self.LightEmittingDiode = LightEmittingDiode
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Power(self): return self.Power
    def set_Power(self, Power): self.Power = Power
    def validate_LightSourceID(self, value):
        # Validate type LightSourceID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LightSourceID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LightSourceID_patterns_, ))
    validate_LightSourceID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:LightSource:\\S+)|(LightSource:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            self.Laser is not None or
            self.Filament is not None or
            self.Arc is not None or
            self.LightEmittingDiode is not None or
            super(LightSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LightSource', mapping_=None):
        element = super(LightSource, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Power is not None:
            element.set('Power', self.gds_format_float(self.Power))
        if self.Laser is not None:
            Laser_ = self.Laser
            Laser_.to_etree(element, name_='Laser', mapping_=mapping_)
        if self.Filament is not None:
            Filament_ = self.Filament
            Filament_.to_etree(element, name_='Filament', mapping_=mapping_)
        if self.Arc is not None:
            Arc_ = self.Arc
            Arc_.to_etree(element, name_='Arc', mapping_=mapping_)
        if self.LightEmittingDiode is not None:
            LightEmittingDiode_ = self.LightEmittingDiode
            LightEmittingDiode_.to_etree(element, name_='LightEmittingDiode', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_LightSourceID(self.ID)    # validate type LightSourceID
        value = find_attr_value_('Power', node)
        if value is not None and 'Power' not in already_processed:
            already_processed.add('Power')
            try:
                self.Power = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Power): %s' % exp)
        super(LightSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Laser':
            obj_ = Laser.factory()
            obj_.build(child_)
            self.Laser = obj_
            obj_.original_tagname_ = 'Laser'
        elif nodeName_ == 'Filament':
            obj_ = Filament.factory()
            obj_.build(child_)
            self.Filament = obj_
            obj_.original_tagname_ = 'Filament'
        elif nodeName_ == 'Arc':
            obj_ = Arc.factory()
            obj_.build(child_)
            self.Arc = obj_
            obj_.original_tagname_ = 'Arc'
        elif nodeName_ == 'LightEmittingDiode':
            obj_ = LightEmittingDiode.factory()
            obj_.build(child_)
            self.LightEmittingDiode = obj_
            obj_.original_tagname_ = 'LightEmittingDiode'
        super(LightSource, self).buildChildren(child_, node, nodeName_, True)
# end class LightSource


class Laser(GeneratedsSuper):
    """Laser types are specified using two attributes - the Type and the
    LaserMedium. Type is the general category of laser. The Medium
    attribute specifies the actual lasing medium for a given laser
    type. The Wavelength of the laser in nanometres[nm]
    FrequencyMultiplication that may be specified. [units:none]
    Whether or not the laser is Tuneable [flag] The Pulse mode of
    the laser. If true the laser has a PockelCell to rotate the
    polarization of the beam. [flag] The is the rate in Hz at which
    the laser pulses if the Pulse type is 'Repetitive'. hertz[Hz]"""
    subclass = None
    superclass = None
    def __init__(self, PockelCell=None, Pulse=None, LaserMedium=None, Tuneable=None, Wavelength=None, FrequencyMultiplication=None, Type=None, RepetitionRate=None, Pump=None):
        self.original_tagname_ = None
        self.PockelCell = _cast(bool, PockelCell)
        self.Pulse = _cast(None, Pulse)
        self.LaserMedium = _cast(None, LaserMedium)
        self.Tuneable = _cast(bool, Tuneable)
        self.Wavelength = _cast(None, Wavelength)
        self.FrequencyMultiplication = _cast(None, FrequencyMultiplication)
        self.Type = _cast(None, Type)
        self.RepetitionRate = _cast(float, RepetitionRate)
        self.Pump = Pump
    def factory(*args_, **kwargs_):
        if Laser.subclass:
            return Laser.subclass(*args_, **kwargs_)
        else:
            return Laser(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pump(self): return self.Pump
    def set_Pump(self, Pump): self.Pump = Pump
    def get_PockelCell(self): return self.PockelCell
    def set_PockelCell(self, PockelCell): self.PockelCell = PockelCell
    def get_Pulse(self): return self.Pulse
    def set_Pulse(self, Pulse): self.Pulse = Pulse
    def get_LaserMedium(self): return self.LaserMedium
    def set_LaserMedium(self, LaserMedium): self.LaserMedium = LaserMedium
    def get_Tuneable(self): return self.Tuneable
    def set_Tuneable(self, Tuneable): self.Tuneable = Tuneable
    def get_Wavelength(self): return self.Wavelength
    def set_Wavelength(self, Wavelength): self.Wavelength = Wavelength
    def get_FrequencyMultiplication(self): return self.FrequencyMultiplication
    def set_FrequencyMultiplication(self, FrequencyMultiplication): self.FrequencyMultiplication = FrequencyMultiplication
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_RepetitionRate(self): return self.RepetitionRate
    def set_RepetitionRate(self, RepetitionRate): self.RepetitionRate = RepetitionRate
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Pump is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Laser', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.PockelCell is not None:
            element.set('PockelCell', self.gds_format_boolean(self.PockelCell))
        if self.Pulse is not None:
            element.set('Pulse', self.gds_format_string(self.Pulse))
        if self.LaserMedium is not None:
            element.set('LaserMedium', self.gds_format_string(self.LaserMedium))
        if self.Tuneable is not None:
            element.set('Tuneable', self.gds_format_boolean(self.Tuneable))
        if self.Wavelength is not None:
            element.set('Wavelength', self.Wavelength)
        if self.FrequencyMultiplication is not None:
            element.set('FrequencyMultiplication', self.FrequencyMultiplication)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.RepetitionRate is not None:
            element.set('RepetitionRate', self.gds_format_float(self.RepetitionRate))
        if self.Pump is not None:
            Pump_ = self.Pump
            Pump_.to_etree(element, name_='Pump', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PockelCell', node)
        if value is not None and 'PockelCell' not in already_processed:
            already_processed.add('PockelCell')
            if value in ('true', '1'):
                self.PockelCell = True
            elif value in ('false', '0'):
                self.PockelCell = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Pulse', node)
        if value is not None and 'Pulse' not in already_processed:
            already_processed.add('Pulse')
            self.Pulse = value
        value = find_attr_value_('LaserMedium', node)
        if value is not None and 'LaserMedium' not in already_processed:
            already_processed.add('LaserMedium')
            self.LaserMedium = value
        value = find_attr_value_('Tuneable', node)
        if value is not None and 'Tuneable' not in already_processed:
            already_processed.add('Tuneable')
            if value in ('true', '1'):
                self.Tuneable = True
            elif value in ('false', '0'):
                self.Tuneable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Wavelength', node)
        if value is not None and 'Wavelength' not in already_processed:
            already_processed.add('Wavelength')
            try:
                self.Wavelength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.Wavelength)    # validate type PositiveInt
        value = find_attr_value_('FrequencyMultiplication', node)
        if value is not None and 'FrequencyMultiplication' not in already_processed:
            already_processed.add('FrequencyMultiplication')
            try:
                self.FrequencyMultiplication = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.FrequencyMultiplication)    # validate type PositiveInt
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('RepetitionRate', node)
        if value is not None and 'RepetitionRate' not in already_processed:
            already_processed.add('RepetitionRate')
            try:
                self.RepetitionRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RepetitionRate): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pump':
            obj_ = Pump.factory()
            obj_.build(child_)
            self.Pump = obj_
            obj_.original_tagname_ = 'Pump'
# end class Laser


class Arc(GeneratedsSuper):
    """The Arc element is used to describe various kinds of Arc lamps - Hg,
    Xe, HgXe. The Power of the Arc is now stored in the LightSource.
    The type of Arc lamp."""
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if Arc.subclass:
            return Arc.subclass(*args_, **kwargs_)
        else:
            return Arc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Arc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Arc


class Filament(GeneratedsSuper):
    """The Filament element is used to describe various kinds of filament
    bulbs such as Incadescent or Halogen. The Power of the Filament
    is now stored in the LightSource. The type of filament."""
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if Filament.subclass:
            return Filament.subclass(*args_, **kwargs_)
        else:
            return Filament(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Filament', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Filament


class LightEmittingDiode(GeneratedsSuper):
    """The LightEmittingDiode element is used to describe various kinds of
    LED lamps. As the LightEmittingDiode is inside a LightSource it
    already has available the values from ManufacturerSpec
    (Manufacturer, Model, SerialNumber, LotNumber) And the values
    from LightSource which includes Power in milliwatts We have
    looked at extending this element but have had a problem
    producing a generic solution. Possible attributes talked about
    adding include: Power in lumens - but this is complicated by
    multi-channel devices like CoolLED where each channel's power is
    different Wavelength Range - not a simple value so would require
    multiple attributes or a child element Angle of Projection -
    this would be further affected by the optics used for filtering
    the naked LED or that combine power from multiple devices These
    values are further affected if you over-drive the LED resulting
    in a more complex system Another issue is that LED's may not be
    used directly for illumination but as drivers for secondary
    emissions from doped fiber optics. This would require the fiber
    optics to be modeled. Thanks to Paul Goodwin of Applied
    Precision of information about this topic."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if LightEmittingDiode.subclass:
            return LightEmittingDiode.subclass(*args_, **kwargs_)
        else:
            return LightEmittingDiode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LightEmittingDiode', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LightEmittingDiode


class Reference(GeneratedsSuper):
    """Reference is an empty complex type that is contained and extended by
    all the *Ref elements and also the Settings Complex Type Each
    *Ref element defines an attribute named ID of simple type *ID
    and no other information Each simple type *ID is restricted to
    the base type LSID with an appropriate pattern"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Reference', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Reference


class FilterRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(FilterRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if FilterRef.subclass:
            return FilterRef.subclass(*args_, **kwargs_)
        else:
            return FilterRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_FilterID(self, value):
        # Validate type FilterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_FilterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_FilterID_patterns_, ))
    validate_FilterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Filter:\\S+)|(Filter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(FilterRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FilterRef', mapping_=None):
        element = super(FilterRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_FilterID(self.ID)    # validate type FilterID
        super(FilterRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FilterRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FilterRef


class MicrobeamManipulationRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(MicrobeamManipulationRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if MicrobeamManipulationRef.subclass:
            return MicrobeamManipulationRef.subclass(*args_, **kwargs_)
        else:
            return MicrobeamManipulationRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_MicrobeamManipulationID(self, value):
        # Validate type MicrobeamManipulationID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_MicrobeamManipulationID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MicrobeamManipulationID_patterns_, ))
    validate_MicrobeamManipulationID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:MicrobeamManipulation:\\S+)|(MicrobeamManipulation:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(MicrobeamManipulationRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='MicrobeamManipulationRef', mapping_=None):
        element = super(MicrobeamManipulationRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_MicrobeamManipulationID(self.ID)    # validate type MicrobeamManipulationID
        super(MicrobeamManipulationRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MicrobeamManipulationRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MicrobeamManipulationRef


class ExperimentRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ExperimentRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ExperimentRef.subclass:
            return ExperimentRef.subclass(*args_, **kwargs_)
        else:
            return ExperimentRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ExperimentID(self, value):
        # Validate type ExperimentID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimentID_patterns_, ))
    validate_ExperimentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experiment:\\S+)|(Experiment:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(ExperimentRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ExperimentRef', mapping_=None):
        element = super(ExperimentRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimentID(self.ID)    # validate type ExperimentID
        super(ExperimentRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExperimentRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExperimentRef


class ChannelRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ChannelRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ChannelRef.subclass:
            return ChannelRef.subclass(*args_, **kwargs_)
        else:
            return ChannelRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ChannelID(self, value):
        # Validate type ChannelID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ChannelID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ChannelID_patterns_, ))
    validate_ChannelID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Channel:\\S+)|(Channel:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(ChannelRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ChannelRef', mapping_=None):
        element = super(ChannelRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ChannelID(self.ID)    # validate type ChannelID
        super(ChannelRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ChannelRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ChannelRef


class ProjectRef(Reference):
    """There may be one or more of these in a Dataset. This empty element
    has a required Project ID attribute that refers to Projects
    defined within the OME element."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ProjectRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ProjectRef.subclass:
            return ProjectRef.subclass(*args_, **kwargs_)
        else:
            return ProjectRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ProjectID(self, value):
        # Validate type ProjectID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ProjectID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ProjectID_patterns_, ))
    validate_ProjectID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Project:\\S+)|(Project:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(ProjectRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ProjectRef', mapping_=None):
        element = super(ProjectRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ProjectID(self.ID)    # validate type ProjectID
        super(ProjectRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProjectRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProjectRef


class ExperimenterRef(Reference):
    """This empty element has a required Experimenter ID and an optional
    DocumentID attribute which refers to one of the Experimenters
    defined within OME."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ExperimenterRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ExperimenterRef.subclass:
            return ExperimenterRef.subclass(*args_, **kwargs_)
        else:
            return ExperimenterRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ExperimenterID(self, value):
        # Validate type ExperimenterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimenterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimenterID_patterns_, ))
    validate_ExperimenterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experimenter:\\S+)|(Experimenter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(ExperimenterRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ExperimenterRef', mapping_=None):
        element = super(ExperimenterRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimenterID(self.ID)    # validate type ExperimenterID
        super(ExperimenterRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExperimenterRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExperimenterRef


class GroupRef(Reference):
    """This empty element has a reference (the Group ID attribute) to a
    Group defined within OME."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(GroupRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if GroupRef.subclass:
            return GroupRef.subclass(*args_, **kwargs_)
        else:
            return GroupRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_GroupID(self, value):
        # Validate type GroupID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_GroupID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_GroupID_patterns_, ))
    validate_GroupID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Group:\\S+)|(Group:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(GroupRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='GroupRef', mapping_=None):
        element = super(GroupRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_GroupID(self.ID)    # validate type GroupID
        super(GroupRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GroupRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GroupRef


class InstrumentRef(Reference):
    """This empty element can be used (via the required Instrument ID
    attribute) to refer to an Instrument defined within OME."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(InstrumentRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if InstrumentRef.subclass:
            return InstrumentRef.subclass(*args_, **kwargs_)
        else:
            return InstrumentRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_InstrumentID(self, value):
        # Validate type InstrumentID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_InstrumentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_InstrumentID_patterns_, ))
    validate_InstrumentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Instrument:\\S+)|(Instrument:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(InstrumentRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='InstrumentRef', mapping_=None):
        element = super(InstrumentRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_InstrumentID(self.ID)    # validate type InstrumentID
        super(InstrumentRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstrumentRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstrumentRef


class DatasetRef(Reference):
    """The DatasetRef element refers to a Dataset by specifying the Dataset
    ID attribute. One or more DatasetRef elements may be listed
    within the Image element to specify what Datasets the Image
    belongs to."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(DatasetRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if DatasetRef.subclass:
            return DatasetRef.subclass(*args_, **kwargs_)
        else:
            return DatasetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DatasetID(self, value):
        # Validate type DatasetID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DatasetID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DatasetID_patterns_, ))
    validate_DatasetID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Dataset:\\S+)|(Dataset:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(DatasetRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DatasetRef', mapping_=None):
        element = super(DatasetRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DatasetID(self.ID)    # validate type DatasetID
        super(DatasetRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DatasetRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DatasetRef


class FilterSetRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(FilterSetRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if FilterSetRef.subclass:
            return FilterSetRef.subclass(*args_, **kwargs_)
        else:
            return FilterSetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_FilterSetID(self, value):
        # Validate type FilterSetID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_FilterSetID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_FilterSetID_patterns_, ))
    validate_FilterSetID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:FilterSet:\\S+)|(FilterSet:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(FilterSetRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FilterSetRef', mapping_=None):
        element = super(FilterSetRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_FilterSetID(self.ID)    # validate type FilterSetID
        super(FilterSetRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FilterSetRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FilterSetRef


class OTFRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(OTFRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if OTFRef.subclass:
            return OTFRef.subclass(*args_, **kwargs_)
        else:
            return OTFRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_OTFID(self, value):
        # Validate type OTFID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_OTFID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OTFID_patterns_, ))
    validate_OTFID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:OTF:\\S+)|(OTF:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(OTFRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='OTFRef', mapping_=None):
        element = super(OTFRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_OTFID(self.ID)    # validate type OTFID
        super(OTFRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OTFRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OTFRef


class Settings(Reference):
    """Settings is an empty complex type that is contained and extended by
    all the *Settings elements Each *Settings element defines an
    attribute named ID of simple type *ID and the other information
    that is needed. Each simple type *ID is restricted to the base
    type LSID with an appropriate pattern"""
    subclass = None
    superclass = Reference
    def __init__(self):
        self.original_tagname_ = None
        super(Settings, self).__init__()
    def factory(*args_, **kwargs_):
        if Settings.subclass:
            return Settings.subclass(*args_, **kwargs_)
        else:
            return Settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Settings, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Settings', mapping_=None):
        element = super(Settings, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Settings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Settings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Settings


class LightSourceSettings(Settings):
    """The Attenuation of the light source [units:none] A fraction, as a
    value from 0.0 to 1.0. The Wavelength of the light source.
    nanometres[nm]"""
    subclass = None
    superclass = Settings
    def __init__(self, Wavelength=None, Attenuation=None, ID=None):
        self.original_tagname_ = None
        super(LightSourceSettings, self).__init__()
        self.Wavelength = _cast(None, Wavelength)
        self.Attenuation = _cast(None, Attenuation)
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if LightSourceSettings.subclass:
            return LightSourceSettings.subclass(*args_, **kwargs_)
        else:
            return LightSourceSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Wavelength(self): return self.Wavelength
    def set_Wavelength(self, Wavelength): self.Wavelength = Wavelength
    def get_Attenuation(self): return self.Attenuation
    def set_Attenuation(self, Attenuation): self.Attenuation = Attenuation
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_PositiveInt(self, value):
        # Validate type PositiveInt, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PositiveInt' % {"value" : value} )
    def validate_PercentFraction(self, value):
        # Validate type PercentFraction, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PercentFraction' % {"value" : value} )
            if value > 1.0:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PercentFraction' % {"value" : value} )
    def validate_LightSourceID(self, value):
        # Validate type LightSourceID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LightSourceID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LightSourceID_patterns_, ))
    validate_LightSourceID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:LightSource:\\S+)|(LightSource:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(LightSourceSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LightSourceSettings', mapping_=None):
        element = super(LightSourceSettings, self).to_etree(parent_element, name_, mapping_)
        if self.Wavelength is not None:
            element.set('Wavelength', self.Wavelength)
        if self.Attenuation is not None:
            element.set('Attenuation', self.Attenuation)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Wavelength', node)
        if value is not None and 'Wavelength' not in already_processed:
            already_processed.add('Wavelength')
            try:
                self.Wavelength = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_PositiveInt(self.Wavelength)    # validate type PositiveInt
        value = find_attr_value_('Attenuation', node)
        if value is not None and 'Attenuation' not in already_processed:
            already_processed.add('Attenuation')
            try:
                self.Attenuation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Attenuation): %s' % exp)
            self.validate_PercentFraction(self.Attenuation)    # validate type PercentFraction
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_LightSourceID(self.ID)    # validate type LightSourceID
        super(LightSourceSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LightSourceSettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LightSourceSettings


class DetectorSettings(Settings):
    """This holds the setting applied to a detector as well as a reference
    to the detector. The ID is the detector used in this case. The
    Offset of the detector. [units none] The Gain of the detector.
    [units:none] The Voltage of the detector. volts[V] The speed at
    which the detector can count pixels. Units of ReadOutRate is
    MHz. This is the bytes per second that can be read from the
    detector (like a baud rate). megahertz[MHz] Represents the
    number of pixels that are combined to form larger pixels."""
    subclass = None
    superclass = Settings
    def __init__(self, Binning=None, ReadOutRate=None, Gain=None, Offset=None, ID=None, Voltage=None):
        self.original_tagname_ = None
        super(DetectorSettings, self).__init__()
        self.Binning = _cast(None, Binning)
        self.ReadOutRate = _cast(float, ReadOutRate)
        self.Gain = _cast(float, Gain)
        self.Offset = _cast(float, Offset)
        self.ID = _cast(None, ID)
        self.Voltage = _cast(float, Voltage)
    def factory(*args_, **kwargs_):
        if DetectorSettings.subclass:
            return DetectorSettings.subclass(*args_, **kwargs_)
        else:
            return DetectorSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Binning(self): return self.Binning
    def set_Binning(self, Binning): self.Binning = Binning
    def get_ReadOutRate(self): return self.ReadOutRate
    def set_ReadOutRate(self, ReadOutRate): self.ReadOutRate = ReadOutRate
    def get_Gain(self): return self.Gain
    def set_Gain(self, Gain): self.Gain = Gain
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Voltage(self): return self.Voltage
    def set_Voltage(self, Voltage): self.Voltage = Voltage
    def validate_DetectorID(self, value):
        # Validate type DetectorID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DetectorID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DetectorID_patterns_, ))
    validate_DetectorID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Detector:\\S+)|(Detector:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(DetectorSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DetectorSettings', mapping_=None):
        element = super(DetectorSettings, self).to_etree(parent_element, name_, mapping_)
        if self.Binning is not None:
            element.set('Binning', self.gds_format_string(self.Binning))
        if self.ReadOutRate is not None:
            element.set('ReadOutRate', self.gds_format_float(self.ReadOutRate))
        if self.Gain is not None:
            element.set('Gain', self.gds_format_float(self.Gain))
        if self.Offset is not None:
            element.set('Offset', self.gds_format_float(self.Offset))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Voltage is not None:
            element.set('Voltage', self.gds_format_float(self.Voltage))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Binning', node)
        if value is not None and 'Binning' not in already_processed:
            already_processed.add('Binning')
            self.Binning = value
        value = find_attr_value_('ReadOutRate', node)
        if value is not None and 'ReadOutRate' not in already_processed:
            already_processed.add('ReadOutRate')
            try:
                self.ReadOutRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ReadOutRate): %s' % exp)
        value = find_attr_value_('Gain', node)
        if value is not None and 'Gain' not in already_processed:
            already_processed.add('Gain')
            try:
                self.Gain = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Gain): %s' % exp)
        value = find_attr_value_('Offset', node)
        if value is not None and 'Offset' not in already_processed:
            already_processed.add('Offset')
            try:
                self.Offset = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Offset): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DetectorID(self.ID)    # validate type DetectorID
        value = find_attr_value_('Voltage', node)
        if value is not None and 'Voltage' not in already_processed:
            already_processed.add('Voltage')
            try:
                self.Voltage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Voltage): %s' % exp)
        super(DetectorSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DetectorSettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DetectorSettings


class ObjectiveSettings(Settings):
    """This holds the setting applied to an objective as well as a
    reference to the objective. The ID is the objective used in this
    case. The CorrectionCollar is it normal an adjustable ring on
    the objective. Each has an arbitrary scale on it so the values
    is unit-less. [units:none] A description of a Medium used for
    the lens. The Medium is the actual immersion medium used in this
    case. The RefractiveIndex is that of the immersion medium. This
    is a ratio so it also unit-less. [units:none]"""
    subclass = None
    superclass = Settings
    def __init__(self, RefractiveIndex=None, CorrectionCollar=None, ID=None, Medium=None):
        self.original_tagname_ = None
        super(ObjectiveSettings, self).__init__()
        self.RefractiveIndex = _cast(float, RefractiveIndex)
        self.CorrectionCollar = _cast(float, CorrectionCollar)
        self.ID = _cast(None, ID)
        self.Medium = _cast(None, Medium)
    def factory(*args_, **kwargs_):
        if ObjectiveSettings.subclass:
            return ObjectiveSettings.subclass(*args_, **kwargs_)
        else:
            return ObjectiveSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RefractiveIndex(self): return self.RefractiveIndex
    def set_RefractiveIndex(self, RefractiveIndex): self.RefractiveIndex = RefractiveIndex
    def get_CorrectionCollar(self): return self.CorrectionCollar
    def set_CorrectionCollar(self, CorrectionCollar): self.CorrectionCollar = CorrectionCollar
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Medium(self): return self.Medium
    def set_Medium(self, Medium): self.Medium = Medium
    def validate_ObjectiveID(self, value):
        # Validate type ObjectiveID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ObjectiveID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ObjectiveID_patterns_, ))
    validate_ObjectiveID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Objective:\\S+)|(Objective:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(ObjectiveSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ObjectiveSettings', mapping_=None):
        element = super(ObjectiveSettings, self).to_etree(parent_element, name_, mapping_)
        if self.RefractiveIndex is not None:
            element.set('RefractiveIndex', self.gds_format_float(self.RefractiveIndex))
        if self.CorrectionCollar is not None:
            element.set('CorrectionCollar', self.gds_format_float(self.CorrectionCollar))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Medium is not None:
            element.set('Medium', self.gds_format_string(self.Medium))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RefractiveIndex', node)
        if value is not None and 'RefractiveIndex' not in already_processed:
            already_processed.add('RefractiveIndex')
            try:
                self.RefractiveIndex = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RefractiveIndex): %s' % exp)
        value = find_attr_value_('CorrectionCollar', node)
        if value is not None and 'CorrectionCollar' not in already_processed:
            already_processed.add('CorrectionCollar')
            try:
                self.CorrectionCollar = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CorrectionCollar): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ObjectiveID(self.ID)    # validate type ObjectiveID
        value = find_attr_value_('Medium', node)
        if value is not None and 'Medium' not in already_processed:
            already_processed.add('Medium')
            self.Medium = value
        super(ObjectiveSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ObjectiveSettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ObjectiveSettings


class External(GeneratedsSuper):
    """Describes a file location. Can optionally specify a portion of a
    file using Offset and a ReadLength. If Offset and ReadLength are
    specified in conjuction with Compression, then they point into
    the uncompressed file. file locationThe digest of the file
    specified in href.Specifies the compression scheme used to
    encode the data."""
    subclass = None
    superclass = None
    def __init__(self, href=None, Compression='none', SHA1=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
        self.Compression = _cast(None, Compression)
        self.SHA1 = _cast(None, SHA1)
    def factory(*args_, **kwargs_):
        if External.subclass:
            return External.subclass(*args_, **kwargs_)
        else:
            return External(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_Compression(self): return self.Compression
    def set_Compression(self, Compression): self.Compression = Compression
    def get_SHA1(self): return self.SHA1
    def set_SHA1(self, SHA1): self.SHA1 = SHA1
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='External', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.href is not None:
            element.set('href', self.gds_format_string(self.href))
        if self.Compression is not None:
            element.set('Compression', self.gds_format_string(self.Compression))
        if self.SHA1 is not None:
            element.set('SHA1', self.SHA1)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('Compression', node)
        if value is not None and 'Compression' not in already_processed:
            already_processed.add('Compression')
            self.Compression = value
        value = find_attr_value_('SHA1', node)
        if value is not None and 'SHA1' not in already_processed:
            already_processed.add('SHA1')
            self.SHA1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class External


class BinData(GeneratedsSuper):
    """The contents of this element are base64-encoded. These are not CDATA
    sections, just a base64 stream.Specifies the compression scheme
    used to encode the data. This is true if the binary data was
    written in BigEndian order. This is dependent on the system
    architecture of the machine that wrote the pixels. True for
    essentially all modern CPUs other than Intel and Alpha. All
    Binary data must be written in the same endian order. Character
    count attribute for the BinData field. This is the length of the
    base-64 encoded block. It allows easy skipping of the block when
    parsing the file."""
    subclass = None
    superclass = None
    def __init__(self, BigEndian=None, Length=None, Compression='none', valueOf_=None):
        self.original_tagname_ = None
        self.BigEndian = _cast(bool, BigEndian)
        self.Length = _cast(None, Length)
        self.Compression = _cast(None, Compression)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BinData.subclass:
            return BinData.subclass(*args_, **kwargs_)
        else:
            return BinData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BigEndian(self): return self.BigEndian
    def set_BigEndian(self, BigEndian): self.BigEndian = BigEndian
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Compression(self): return self.Compression
    def set_Compression(self, Compression): self.Compression = Compression
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BinData', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.BigEndian is not None:
            element.set('BigEndian', self.gds_format_boolean(self.BigEndian))
        if self.Length is not None:
            element.set('Length', self.Length)
        if self.Compression is not None:
            element.set('Compression', self.gds_format_string(self.Compression))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BigEndian', node)
        if value is not None and 'BigEndian' not in already_processed:
            already_processed.add('BigEndian')
            if value in ('true', '1'):
                self.BigEndian = True
            elif value in ('false', '0'):
                self.BigEndian = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Length', node)
        if value is not None and 'Length' not in already_processed:
            already_processed.add('Length')
            self.Length = value
        value = find_attr_value_('Compression', node)
        if value is not None and 'Compression' not in already_processed:
            already_processed.add('Compression')
            self.Compression = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BinData


class BinaryFile(GeneratedsSuper):
    """Describes a binary file. Size (in bytes) of the uncompressed file."""
    subclass = None
    superclass = None
    def __init__(self, MIMEType=None, Size=None, FileName=None, External=None, BinData=None):
        self.original_tagname_ = None
        self.MIMEType = _cast(None, MIMEType)
        self.Size = _cast(None, Size)
        self.FileName = _cast(None, FileName)
        self.External = External
        self.BinData = BinData
    def factory(*args_, **kwargs_):
        if BinaryFile.subclass:
            return BinaryFile.subclass(*args_, **kwargs_)
        else:
            return BinaryFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_External(self): return self.External
    def set_External(self, External): self.External = External
    def get_BinData(self): return self.BinData
    def set_BinData(self, BinData): self.BinData = BinData
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def get_FileName(self): return self.FileName
    def set_FileName(self, FileName): self.FileName = FileName
    def hasContent_(self):
        if (
            self.External is not None or
            self.BinData is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BinaryFile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.MIMEType is not None:
            element.set('MIMEType', self.gds_format_string(self.MIMEType))
        if self.Size is not None:
            element.set('Size', self.Size)
        if self.FileName is not None:
            element.set('FileName', self.gds_format_string(self.FileName))
        if self.External is not None:
            External_ = self.External
            External_.to_etree(element, name_='External', mapping_=mapping_)
        if self.BinData is not None:
            BinData_ = self.BinData
            BinData_.to_etree(element, name_='BinData', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MIMEType', node)
        if value is not None and 'MIMEType' not in already_processed:
            already_processed.add('MIMEType')
            self.MIMEType = value
        value = find_attr_value_('Size', node)
        if value is not None and 'Size' not in already_processed:
            already_processed.add('Size')
            self.Size = value
        value = find_attr_value_('FileName', node)
        if value is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            self.FileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'External':
            obj_ = External.factory()
            obj_.build(child_)
            self.External = obj_
            obj_.original_tagname_ = 'External'
        elif nodeName_ == 'BinData':
            obj_ = BinData.factory()
            obj_.build(child_)
            self.BinData = obj_
            obj_.original_tagname_ = 'BinData'
# end class BinaryFile


class Microscope(ManufacturerSpec):
    """The microscope's manufacturer specification."""
    subclass = None
    superclass = ManufacturerSpec
    def __init__(self, LotNumber=None, Model=None, SerialNumber=None, Manufacturer=None, Type=None):
        self.original_tagname_ = None
        super(Microscope, self).__init__(LotNumber, Model, SerialNumber, Manufacturer, )
        self.Type = _cast(None, Type)
    def factory(*args_, **kwargs_):
        if Microscope.subclass:
            return Microscope.subclass(*args_, **kwargs_)
        else:
            return Microscope(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            super(Microscope, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Microscope', mapping_=None):
        element = super(Microscope, self).to_etree(parent_element, name_, mapping_)
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        super(Microscope, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Microscope, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Microscope


class Leader(Reference):
    """Contact information for a Group leader specified using a reference
    to an Experimenter element defined elsewhere in the document."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(Leader, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if Leader.subclass:
            return Leader.subclass(*args_, **kwargs_)
        else:
            return Leader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ExperimenterID(self, value):
        # Validate type ExperimenterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimenterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimenterID_patterns_, ))
    validate_ExperimenterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experimenter:\\S+)|(Experimenter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Leader, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Leader', mapping_=None):
        element = super(Leader, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimenterID(self.ID)    # validate type ExperimenterID
        super(Leader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Leader, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Leader


class Contact(Reference):
    """The Contact element describes the contact person for a group of
    experimenters - typically a project leader or lab manager. This
    person is specified as a reference to an OME experimenter."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(Contact, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ExperimenterID(self, value):
        # Validate type ExperimenterID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ExperimenterID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ExperimenterID_patterns_, ))
    validate_ExperimenterID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Experimenter:\\S+)|(Experimenter:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Contact, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Contact', mapping_=None):
        element = super(Contact, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ExperimenterID(self.ID)    # validate type ExperimenterID
        super(Contact, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Contact, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Contact


class DichroicRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(DichroicRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if DichroicRef.subclass:
            return DichroicRef.subclass(*args_, **kwargs_)
        else:
            return DichroicRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_DichroicID(self, value):
        # Validate type DichroicID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_DichroicID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_DichroicID_patterns_, ))
    validate_DichroicID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Dichroic:\\S+)|(Dichroic:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(DichroicRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DichroicRef', mapping_=None):
        element = super(DichroicRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_DichroicID(self.ID)    # validate type DichroicID
        super(DichroicRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DichroicRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DichroicRef


class Pump(Reference):
    """The Pump element is a reference to a LightSource. It is used within
    the Laser element to specify the light source for the laser's
    pump (if any)."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(Pump, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if Pump.subclass:
            return Pump.subclass(*args_, **kwargs_)
        else:
            return Pump(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_LightSourceID(self, value):
        # Validate type LightSourceID, a restriction on LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LightSourceID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LightSourceID_patterns_, ))
    validate_LightSourceID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:LightSource:\\S+)|(LightSource:\\S+)$'], ['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:\\S+:\\S+)|(\\S+:\\S+)$']]
    def hasContent_(self):
        if (
            super(Pump, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Pump', mapping_=None):
        element = super(Pump, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_LightSourceID(self.ID)    # validate type LightSourceID
        super(Pump, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Pump, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Pump


class Plate(GeneratedsSuper):
    """This element identifies microtiter plates within a screen. A plate
    can belong to more than one screen. The Screen(s) that a plate
    belongs to are specified by the ScreenRef element. The Plate ID
    and Name attributes are required. The Wells in a plate are
    numbers from the top-left corner in a grid starting at zero. i.e
    The top-left well of a plate is index (0,0) The Name identifies
    the plate to the user. It is used much like the ID, and so must
    be unique within the document. A textual annotation of the
    current state of the plate with respect to the experiment work-
    flow; e.g. 1. Seed cell: done; 2. Transfection: done; 3. Gel
    doc: todo. The ExternalIdentifier attribute may contain a
    reference to an external database. The ColumnNamingConvention
    The RowNamingConvention This defines the X position to use for
    the origin of the fields (individual images) taken in a well. It
    is used with the PositionX in the WellSample to display the
    fields in the correct position relative to each other. Each Well
    in the plate has the same well origin. [units:none] In the OMERO
    clients by convention we display the WellOrigin in the center of
    the view. This defines the Y position to use for the origin of
    the fields (individual images) taken in a well. It is used with
    the PositionY in the WellSample to display the fields in the
    correct position relative to each other. Each Well in the plate
    has the same well origin. [units:none] In the OMERO clients by
    convention we display the WellOrigin in the center of the view.
    The number of rows in the plate The number of columns in the
    plate"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, Rows=None, ExternalIdentifier=None, RowNamingConvention=None, ColumnNamingConvention=None, WellOriginY=None, WellOriginX=None, ID=None, Columns=None, Name=None, Description=None, ScreenRef=None, Well=None, AnnotationRef=None, PlateAcquisition=None):
        self.original_tagname_ = None
        self.Status = _cast(None, Status)
        self.Rows = _cast(None, Rows)
        self.ExternalIdentifier = _cast(None, ExternalIdentifier)
        self.RowNamingConvention = _cast(None, RowNamingConvention)
        self.ColumnNamingConvention = _cast(None, ColumnNamingConvention)
        self.WellOriginY = _cast(float, WellOriginY)
        self.WellOriginX = _cast(float, WellOriginX)
        self.ID = _cast(None, ID)
        self.Columns = _cast(None, Columns)
        self.Name = _cast(None, Name)
        self.Description = Description
        self.validate_DescriptionType11(self.Description)
        if ScreenRef is None:
            self.ScreenRef = []
        else:
            self.ScreenRef = ScreenRef
        if Well is None:
            self.Well = []
        else:
            self.Well = Well
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
        if PlateAcquisition is None:
            self.PlateAcquisition = []
        else:
            self.PlateAcquisition = PlateAcquisition
    def factory(*args_, **kwargs_):
        if Plate.subclass:
            return Plate.subclass(*args_, **kwargs_)
        else:
            return Plate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ScreenRef(self): return self.ScreenRef
    def set_ScreenRef(self, ScreenRef): self.ScreenRef = ScreenRef
    def add_ScreenRef(self, value): self.ScreenRef.append(value)
    def insert_ScreenRef_at(self, index, value): self.ScreenRef.insert(index, value)
    def replace_ScreenRef_at(self, index, value): self.ScreenRef[index] = value
    def get_Well(self): return self.Well
    def set_Well(self, Well): self.Well = Well
    def add_Well(self, value): self.Well.append(value)
    def insert_Well_at(self, index, value): self.Well.insert(index, value)
    def replace_Well_at(self, index, value): self.Well[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_PlateAcquisition(self): return self.PlateAcquisition
    def set_PlateAcquisition(self, PlateAcquisition): self.PlateAcquisition = PlateAcquisition
    def add_PlateAcquisition(self, value): self.PlateAcquisition.append(value)
    def insert_PlateAcquisition_at(self, index, value): self.PlateAcquisition.insert(index, value)
    def replace_PlateAcquisition_at(self, index, value): self.PlateAcquisition[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Rows(self): return self.Rows
    def set_Rows(self, Rows): self.Rows = Rows
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def get_RowNamingConvention(self): return self.RowNamingConvention
    def set_RowNamingConvention(self, RowNamingConvention): self.RowNamingConvention = RowNamingConvention
    def get_ColumnNamingConvention(self): return self.ColumnNamingConvention
    def set_ColumnNamingConvention(self, ColumnNamingConvention): self.ColumnNamingConvention = ColumnNamingConvention
    def get_WellOriginY(self): return self.WellOriginY
    def set_WellOriginY(self, WellOriginY): self.WellOriginY = WellOriginY
    def get_WellOriginX(self): return self.WellOriginX
    def set_WellOriginX(self, WellOriginX): self.WellOriginX = WellOriginX
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Columns(self): return self.Columns
    def set_Columns(self, Columns): self.Columns = Columns
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType11(self, value):
        # Validate type DescriptionType11, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NamingConvention(self, value):
        # Validate type NamingConvention, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['letter', 'number']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NamingConvention' % {"value" : value.encode("utf-8")} )
    def validate_PlateID(self, value):
        # Validate type PlateID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlateID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlateID_patterns_, ))
    validate_PlateID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Plate:\\S+)|(Plate:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ScreenRef or
            self.Well or
            self.AnnotationRef or
            self.PlateAcquisition
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Plate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Status is not None:
            element.set('Status', self.gds_format_string(self.Status))
        if self.Rows is not None:
            element.set('Rows', self.Rows)
        if self.ExternalIdentifier is not None:
            element.set('ExternalIdentifier', self.gds_format_string(self.ExternalIdentifier))
        if self.RowNamingConvention is not None:
            element.set('RowNamingConvention', self.RowNamingConvention)
        if self.ColumnNamingConvention is not None:
            element.set('ColumnNamingConvention', self.ColumnNamingConvention)
        if self.WellOriginY is not None:
            element.set('WellOriginY', self.gds_format_float(self.WellOriginY))
        if self.WellOriginX is not None:
            element.set('WellOriginX', self.gds_format_float(self.WellOriginX))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Columns is not None:
            element.set('Columns', self.Columns)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        for ScreenRef_ in self.ScreenRef:
            ScreenRef_.to_etree(element, name_='ScreenRef', mapping_=mapping_)
        for Well_ in self.Well:
            Well_.to_etree(element, name_='Well', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        for PlateAcquisition_ in self.PlateAcquisition:
            PlateAcquisition_.to_etree(element, name_='PlateAcquisition', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
        value = find_attr_value_('Rows', node)
        if value is not None and 'Rows' not in already_processed:
            already_processed.add('Rows')
            self.Rows = value
        value = find_attr_value_('ExternalIdentifier', node)
        if value is not None and 'ExternalIdentifier' not in already_processed:
            already_processed.add('ExternalIdentifier')
            self.ExternalIdentifier = value
        value = find_attr_value_('RowNamingConvention', node)
        if value is not None and 'RowNamingConvention' not in already_processed:
            already_processed.add('RowNamingConvention')
            self.RowNamingConvention = value
            self.validate_NamingConvention(self.RowNamingConvention)    # validate type NamingConvention
        value = find_attr_value_('ColumnNamingConvention', node)
        if value is not None and 'ColumnNamingConvention' not in already_processed:
            already_processed.add('ColumnNamingConvention')
            self.ColumnNamingConvention = value
            self.validate_NamingConvention(self.ColumnNamingConvention)    # validate type NamingConvention
        value = find_attr_value_('WellOriginY', node)
        if value is not None and 'WellOriginY' not in already_processed:
            already_processed.add('WellOriginY')
            try:
                self.WellOriginY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WellOriginY): %s' % exp)
        value = find_attr_value_('WellOriginX', node)
        if value is not None and 'WellOriginX' not in already_processed:
            already_processed.add('WellOriginX')
            try:
                self.WellOriginX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (WellOriginX): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PlateID(self.ID)    # validate type PlateID
        value = find_attr_value_('Columns', node)
        if value is not None and 'Columns' not in already_processed:
            already_processed.add('Columns')
            self.Columns = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType11(self.Description)    # validate type DescriptionType11
        elif nodeName_ == 'ScreenRef':
            obj_ = ScreenRefType.factory()
            obj_.build(child_)
            self.ScreenRef.append(obj_)
            obj_.original_tagname_ = 'ScreenRef'
        elif nodeName_ == 'Well':
            obj_ = Well.factory()
            obj_.build(child_)
            self.Well.append(obj_)
            obj_.original_tagname_ = 'Well'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
        elif nodeName_ == 'PlateAcquisition':
            obj_ = PlateAcquisition.factory()
            obj_.build(child_)
            self.PlateAcquisition.append(obj_)
            obj_.original_tagname_ = 'PlateAcquisition'
# end class Plate


class Reagent(GeneratedsSuper):
    """Reagent is used to describe a chemical or some other physical
    experimental parameter. A short name for the reagent This is a
    reference to an external (to OME) representation of the Reagent.
    It serves as a foreign key into an external database. - It is
    sometimes refereed to as ExternalIdentifier."""
    subclass = None
    superclass = None
    def __init__(self, ReagentIdentifier=None, ID=None, Name=None, Description=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.ReagentIdentifier = _cast(None, ReagentIdentifier)
        self.ID = _cast(None, ID)
        self.Name = _cast(None, Name)
        self.Description = Description
        self.validate_DescriptionType12(self.Description)
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Reagent.subclass:
            return Reagent.subclass(*args_, **kwargs_)
        else:
            return Reagent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_ReagentIdentifier(self): return self.ReagentIdentifier
    def set_ReagentIdentifier(self, ReagentIdentifier): self.ReagentIdentifier = ReagentIdentifier
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType12(self, value):
        # Validate type DescriptionType12, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ReagentID(self, value):
        # Validate type ReagentID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ReagentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ReagentID_patterns_, ))
    validate_ReagentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Reagent:\\S+)|(Reagent:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Reagent', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.ReagentIdentifier is not None:
            element.set('ReagentIdentifier', self.gds_format_string(self.ReagentIdentifier))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ReagentIdentifier', node)
        if value is not None and 'ReagentIdentifier' not in already_processed:
            already_processed.add('ReagentIdentifier')
            self.ReagentIdentifier = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ReagentID(self.ID)    # validate type ReagentID
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType12(self.Description)    # validate type DescriptionType12
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Reagent


class ReagentRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ReagentRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ReagentRef.subclass:
            return ReagentRef.subclass(*args_, **kwargs_)
        else:
            return ReagentRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ReagentID(self, value):
        # Validate type ReagentID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ReagentID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ReagentID_patterns_, ))
    validate_ReagentID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Reagent:\\S+)|(Reagent:\\S+)$']]
    def hasContent_(self):
        if (
            super(ReagentRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ReagentRef', mapping_=None):
        element = super(ReagentRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ReagentID(self.ID)    # validate type ReagentID
        super(ReagentRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReagentRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReagentRef


class Screen(GeneratedsSuper):
    """The Screen element is a grouping for Plates. The required attribute
    is the Screen's Name and ID - both must be unique within the
    document. The Screen element may contain an ExternalRef
    attribute that refers to an external database. A description of
    the screen may be specified in the Description element. Screens
    may contain overlapping sets of Plates i.e. Screens and Plates
    have a many-to-many relationship. Plates contain one or more
    ScreenRef elements to specify what screens they belong to. A
    pointer to an externally defined protocol, usually in a
    screening database. A description of the screen protocol; may
    contain very detailed information to reproduce some of that
    found in a screening database. A description of the set of
    reagents; may contain very detailed information to reproduce
    some of that information found in a screening database. A
    pointer to an externally defined set of reagents, usually in a
    screening database/automation database. A human readable
    identifier for the screen type; e.g. RNAi, cDNA, SiRNA, etc.
    This string is likely to become an enumeration in future
    releases."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, ProtocolDescription=None, ProtocolIdentifier=None, ReagentSetDescription=None, Type=None, ID=None, ReagentSetIdentifier=None, Description=None, Reagent=None, PlateRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.Name = _cast(None, Name)
        self.ProtocolDescription = _cast(None, ProtocolDescription)
        self.ProtocolIdentifier = _cast(None, ProtocolIdentifier)
        self.ReagentSetDescription = _cast(None, ReagentSetDescription)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.ReagentSetIdentifier = _cast(None, ReagentSetIdentifier)
        self.Description = Description
        self.validate_DescriptionType13(self.Description)
        if Reagent is None:
            self.Reagent = []
        else:
            self.Reagent = Reagent
        if PlateRef is None:
            self.PlateRef = []
        else:
            self.PlateRef = PlateRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Screen.subclass:
            return Screen.subclass(*args_, **kwargs_)
        else:
            return Screen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Reagent(self): return self.Reagent
    def set_Reagent(self, Reagent): self.Reagent = Reagent
    def add_Reagent(self, value): self.Reagent.append(value)
    def insert_Reagent_at(self, index, value): self.Reagent.insert(index, value)
    def replace_Reagent_at(self, index, value): self.Reagent[index] = value
    def get_PlateRef(self): return self.PlateRef
    def set_PlateRef(self, PlateRef): self.PlateRef = PlateRef
    def add_PlateRef(self, value): self.PlateRef.append(value)
    def insert_PlateRef_at(self, index, value): self.PlateRef.insert(index, value)
    def replace_PlateRef_at(self, index, value): self.PlateRef[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_ProtocolDescription(self): return self.ProtocolDescription
    def set_ProtocolDescription(self, ProtocolDescription): self.ProtocolDescription = ProtocolDescription
    def get_ProtocolIdentifier(self): return self.ProtocolIdentifier
    def set_ProtocolIdentifier(self, ProtocolIdentifier): self.ProtocolIdentifier = ProtocolIdentifier
    def get_ReagentSetDescription(self): return self.ReagentSetDescription
    def set_ReagentSetDescription(self, ReagentSetDescription): self.ReagentSetDescription = ReagentSetDescription
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ReagentSetIdentifier(self): return self.ReagentSetIdentifier
    def set_ReagentSetIdentifier(self, ReagentSetIdentifier): self.ReagentSetIdentifier = ReagentSetIdentifier
    def validate_DescriptionType13(self, value):
        # Validate type DescriptionType13, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ScreenID(self, value):
        # Validate type ScreenID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ScreenID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ScreenID_patterns_, ))
    validate_ScreenID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Screen:\\S+)|(Screen:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Reagent or
            self.PlateRef or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Screen', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.ProtocolDescription is not None:
            element.set('ProtocolDescription', self.gds_format_string(self.ProtocolDescription))
        if self.ProtocolIdentifier is not None:
            element.set('ProtocolIdentifier', self.gds_format_string(self.ProtocolIdentifier))
        if self.ReagentSetDescription is not None:
            element.set('ReagentSetDescription', self.gds_format_string(self.ReagentSetDescription))
        if self.Type is not None:
            element.set('Type', self.gds_format_string(self.Type))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.ReagentSetIdentifier is not None:
            element.set('ReagentSetIdentifier', self.gds_format_string(self.ReagentSetIdentifier))
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        for Reagent_ in self.Reagent:
            Reagent_.to_etree(element, name_='Reagent', mapping_=mapping_)
        for PlateRef_ in self.PlateRef:
            PlateRef_.to_etree(element, name_='PlateRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
        value = find_attr_value_('ProtocolDescription', node)
        if value is not None and 'ProtocolDescription' not in already_processed:
            already_processed.add('ProtocolDescription')
            self.ProtocolDescription = value
        value = find_attr_value_('ProtocolIdentifier', node)
        if value is not None and 'ProtocolIdentifier' not in already_processed:
            already_processed.add('ProtocolIdentifier')
            self.ProtocolIdentifier = value
        value = find_attr_value_('ReagentSetDescription', node)
        if value is not None and 'ReagentSetDescription' not in already_processed:
            already_processed.add('ReagentSetDescription')
            self.ReagentSetDescription = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ScreenID(self.ID)    # validate type ScreenID
        value = find_attr_value_('ReagentSetIdentifier', node)
        if value is not None and 'ReagentSetIdentifier' not in already_processed:
            already_processed.add('ReagentSetIdentifier')
            self.ReagentSetIdentifier = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType13(self.Description)    # validate type DescriptionType13
        elif nodeName_ == 'Reagent':
            obj_ = Reagent.factory()
            obj_.build(child_)
            self.Reagent.append(obj_)
            obj_.original_tagname_ = 'Reagent'
        elif nodeName_ == 'PlateRef':
            obj_ = PlateRefType.factory()
            obj_.build(child_)
            self.PlateRef.append(obj_)
            obj_.original_tagname_ = 'PlateRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Screen


class PlateAcquisition(GeneratedsSuper):
    """PlateAcquisition is used to describe a single acquisition run for a
    plate. This object is used to record the set of images acquired
    in a single acquisition run. The Images for this run are linked
    to PlateAcquisition through WellSample. Time when the last image
    of this acquisition was collected Time when the first image of
    this acquisition was collected The maximum number of fields
    (well samples) in any well in this PlateAcquisition. This is
    only used to speed up user interaction by stopping the reading
    of every well sample."""
    subclass = None
    superclass = None
    def __init__(self, MaximumFieldCount=None, EndTime=None, ID=None, StartTime=None, Name=None, Description=None, WellSampleRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.MaximumFieldCount = _cast(None, MaximumFieldCount)
        if isinstance(EndTime, basestring):
            initvalue_ = datetime_.datetime.strptime(EndTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EndTime
        self.EndTime = initvalue_
        self.ID = _cast(None, ID)
        if isinstance(StartTime, basestring):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        self.Name = _cast(None, Name)
        self.Description = Description
        self.validate_DescriptionType14(self.Description)
        if WellSampleRef is None:
            self.WellSampleRef = []
        else:
            self.WellSampleRef = WellSampleRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if PlateAcquisition.subclass:
            return PlateAcquisition.subclass(*args_, **kwargs_)
        else:
            return PlateAcquisition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_WellSampleRef(self): return self.WellSampleRef
    def set_WellSampleRef(self, WellSampleRef): self.WellSampleRef = WellSampleRef
    def add_WellSampleRef(self, value): self.WellSampleRef.append(value)
    def insert_WellSampleRef_at(self, index, value): self.WellSampleRef.insert(index, value)
    def replace_WellSampleRef_at(self, index, value): self.WellSampleRef[index] = value
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_MaximumFieldCount(self): return self.MaximumFieldCount
    def set_MaximumFieldCount(self, MaximumFieldCount): self.MaximumFieldCount = MaximumFieldCount
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType14(self, value):
        # Validate type DescriptionType14, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlateAcquisitionID(self, value):
        # Validate type PlateAcquisitionID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlateAcquisitionID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlateAcquisitionID_patterns_, ))
    validate_PlateAcquisitionID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:PlateAcquisition:\\S+)|(PlateAcquisition:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.WellSampleRef or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PlateAcquisition', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.MaximumFieldCount is not None:
            element.set('MaximumFieldCount', self.MaximumFieldCount)
        if self.EndTime is not None:
            element.set('EndTime', self.gds_format_datetime(self.EndTime))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.StartTime is not None:
            element.set('StartTime', self.gds_format_datetime(self.StartTime))
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        for WellSampleRef_ in self.WellSampleRef:
            WellSampleRef_.to_etree(element, name_='WellSampleRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MaximumFieldCount', node)
        if value is not None and 'MaximumFieldCount' not in already_processed:
            already_processed.add('MaximumFieldCount')
            self.MaximumFieldCount = value
        value = find_attr_value_('EndTime', node)
        if value is not None and 'EndTime' not in already_processed:
            already_processed.add('EndTime')
            try:
                self.EndTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (EndTime): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PlateAcquisitionID(self.ID)    # validate type PlateAcquisitionID
        value = find_attr_value_('StartTime', node)
        if value is not None and 'StartTime' not in already_processed:
            already_processed.add('StartTime')
            try:
                self.StartTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (StartTime): %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType14(self.Description)    # validate type DescriptionType14
        elif nodeName_ == 'WellSampleRef':
            obj_ = WellSampleRef.factory()
            obj_.build(child_)
            self.WellSampleRef.append(obj_)
            obj_.original_tagname_ = 'WellSampleRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class PlateAcquisition


class Well(GeneratedsSuper):
    """A Well is a component of the Well/Plate/Screen construct to describe
    screening applications. A Well has a number of WellSample
    elements that link to the Images collected in this well. The
    ReagentRef links any Reagents that were used in this Well. A
    well is part of only one Plate. The origin for the row and
    column identifiers is the top left corner of the plate starting
    at zero. i.e The top left well of a plate is index (0,0) This is
    the column index of the well, the origin is the top left corner
    of the plate with the first column of cells being column zero.
    i.e top left is (0,0) The combination of Row, Column has to be
    unique for each well in a plate. This is the row index of the
    well, the origin is the top left corner of the plate with the
    first row of wells being row zero. i.e top left is (0,0) The
    combination of Row, Column has to be unique for each well in a
    plate. A description of the externally defined identifier for
    this plate. The ExternalIdentifier attribute may contain a
    reference to an external database. A human readable identifier
    for the screening status. e.g. empty, positive control, negative
    control, control, experimental, etc. This string is likely to
    become an enumeration in future releases. A marker color used to
    highlight the well - encoded as RGBA The default value
    "-2147483648" is #FFFFFFFF so solid white (it is a signed 32 bit
    value)"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ExternalIdentifier=None, Column=None, ExternalDescription=None, Color=-2147483648, ID=None, Row=None, WellSample=None, ReagentRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.Status = _cast(None, Status)
        self.ExternalIdentifier = _cast(None, ExternalIdentifier)
        self.Column = _cast(None, Column)
        self.ExternalDescription = _cast(None, ExternalDescription)
        self.Color = _cast(int, Color)
        self.ID = _cast(None, ID)
        self.Row = _cast(None, Row)
        if WellSample is None:
            self.WellSample = []
        else:
            self.WellSample = WellSample
        self.ReagentRef = ReagentRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if Well.subclass:
            return Well.subclass(*args_, **kwargs_)
        else:
            return Well(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WellSample(self): return self.WellSample
    def set_WellSample(self, WellSample): self.WellSample = WellSample
    def add_WellSample(self, value): self.WellSample.append(value)
    def insert_WellSample_at(self, index, value): self.WellSample.insert(index, value)
    def replace_WellSample_at(self, index, value): self.WellSample[index] = value
    def get_ReagentRef(self): return self.ReagentRef
    def set_ReagentRef(self, ReagentRef): self.ReagentRef = ReagentRef
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def get_Column(self): return self.Column
    def set_Column(self, Column): self.Column = Column
    def get_ExternalDescription(self): return self.ExternalDescription
    def set_ExternalDescription(self, ExternalDescription): self.ExternalDescription = ExternalDescription
    def get_Color(self): return self.Color
    def set_Color(self, Color): self.Color = Color
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Row(self): return self.Row
    def set_Row(self, Row): self.Row = Row
    def validate_WellID(self, value):
        # Validate type WellID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_WellID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_WellID_patterns_, ))
    validate_WellID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Well:\\S+)|(Well:\\S+)$']]
    def hasContent_(self):
        if (
            self.WellSample or
            self.ReagentRef is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Well', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Status is not None:
            element.set('Status', self.gds_format_string(self.Status))
        if self.ExternalIdentifier is not None:
            element.set('ExternalIdentifier', self.gds_format_string(self.ExternalIdentifier))
        if self.Column is not None:
            element.set('Column', self.Column)
        if self.ExternalDescription is not None:
            element.set('ExternalDescription', self.gds_format_string(self.ExternalDescription))
        if self.Color is not None:
            element.set('Color', self.gds_format_integer(self.Color))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Row is not None:
            element.set('Row', self.Row)
        for WellSample_ in self.WellSample:
            WellSample_.to_etree(element, name_='WellSample', mapping_=mapping_)
        if self.ReagentRef is not None:
            ReagentRef_ = self.ReagentRef
            ReagentRef_.to_etree(element, name_='ReagentRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
        value = find_attr_value_('ExternalIdentifier', node)
        if value is not None and 'ExternalIdentifier' not in already_processed:
            already_processed.add('ExternalIdentifier')
            self.ExternalIdentifier = value
        value = find_attr_value_('Column', node)
        if value is not None and 'Column' not in already_processed:
            already_processed.add('Column')
            self.Column = value
        value = find_attr_value_('ExternalDescription', node)
        if value is not None and 'ExternalDescription' not in already_processed:
            already_processed.add('ExternalDescription')
            self.ExternalDescription = value
        value = find_attr_value_('Color', node)
        if value is not None and 'Color' not in already_processed:
            already_processed.add('Color')
            try:
                self.Color = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_WellID(self.ID)    # validate type WellID
        value = find_attr_value_('Row', node)
        if value is not None and 'Row' not in already_processed:
            already_processed.add('Row')
            self.Row = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WellSample':
            obj_ = WellSample.factory()
            obj_.build(child_)
            self.WellSample.append(obj_)
            obj_.original_tagname_ = 'WellSample'
        elif nodeName_ == 'ReagentRef':
            obj_ = ReagentRef.factory()
            obj_.build(child_)
            self.ReagentRef = obj_
            obj_.original_tagname_ = 'ReagentRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Well


class WellSample(GeneratedsSuper):
    """WellSample is an individual image that has been captured within a
    Well. The X position of the field (image) within the well
    relative to the well origin defined on the Plate. The Y position
    of the field (image) within the well relative to the well origin
    defined on the Plate. The time-point at which the image started
    to be collected This records the order of the well samples. Each
    index should be unique for a given plate but they do not have to
    be sequential, there may be gaps if part of the dataset is
    missing. In the user interface the displayed value of the index
    will be calculated modulo the number of PlateAcquisitions for
    the plate."""
    subclass = None
    superclass = None
    def __init__(self, Index=None, PositionX=None, PositionY=None, ID=None, Timepoint=None, ImageRef=None, AnnotationRef=None):
        self.original_tagname_ = None
        self.Index = _cast(None, Index)
        self.PositionX = _cast(float, PositionX)
        self.PositionY = _cast(float, PositionY)
        self.ID = _cast(None, ID)
        if isinstance(Timepoint, basestring):
            initvalue_ = datetime_.datetime.strptime(Timepoint, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Timepoint
        self.Timepoint = initvalue_
        self.ImageRef = ImageRef
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
    def factory(*args_, **kwargs_):
        if WellSample.subclass:
            return WellSample.subclass(*args_, **kwargs_)
        else:
            return WellSample(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImageRef(self): return self.ImageRef
    def set_ImageRef(self, ImageRef): self.ImageRef = ImageRef
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_PositionX(self): return self.PositionX
    def set_PositionX(self, PositionX): self.PositionX = PositionX
    def get_PositionY(self): return self.PositionY
    def set_PositionY(self, PositionY): self.PositionY = PositionY
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Timepoint(self): return self.Timepoint
    def set_Timepoint(self, Timepoint): self.Timepoint = Timepoint
    def validate_WellSampleID(self, value):
        # Validate type WellSampleID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_WellSampleID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_WellSampleID_patterns_, ))
    validate_WellSampleID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:WellSample:\\S+)|(WellSample:\\S+)$']]
    def hasContent_(self):
        if (
            self.ImageRef is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WellSample', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Index is not None:
            element.set('Index', self.Index)
        if self.PositionX is not None:
            element.set('PositionX', self.gds_format_float(self.PositionX))
        if self.PositionY is not None:
            element.set('PositionY', self.gds_format_float(self.PositionY))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Timepoint is not None:
            element.set('Timepoint', self.gds_format_datetime(self.Timepoint))
        if self.ImageRef is not None:
            ImageRef_ = self.ImageRef
            ImageRef_.to_etree(element, name_='ImageRef', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Index', node)
        if value is not None and 'Index' not in already_processed:
            already_processed.add('Index')
            self.Index = value
        value = find_attr_value_('PositionX', node)
        if value is not None and 'PositionX' not in already_processed:
            already_processed.add('PositionX')
            try:
                self.PositionX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionX): %s' % exp)
        value = find_attr_value_('PositionY', node)
        if value is not None and 'PositionY' not in already_processed:
            already_processed.add('PositionY')
            try:
                self.PositionY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PositionY): %s' % exp)
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_WellSampleID(self.ID)    # validate type WellSampleID
        value = find_attr_value_('Timepoint', node)
        if value is not None and 'Timepoint' not in already_processed:
            already_processed.add('Timepoint')
            try:
                self.Timepoint = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (Timepoint): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImageRef':
            obj_ = ImageRef.factory()
            obj_.build(child_)
            self.ImageRef = obj_
            obj_.original_tagname_ = 'ImageRef'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class WellSample


class ImageRef(Reference):
    """The ImageRef element is a reference to a OME:Image element. Note: at
    present this is only used from SPW. If it is used more widely in
    the future it will be moved into the main OME schema."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ImageRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ImageRef.subclass:
            return ImageRef.subclass(*args_, **kwargs_)
        else:
            return ImageRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def hasContent_(self):
        if (
            super(ImageRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ImageRef', mapping_=None):
        element = super(ImageRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        super(ImageRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ImageRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ImageRef


class WellSampleRef(Reference):
    """The WellSampleRef element is a reference to a WellSample element."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(WellSampleRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if WellSampleRef.subclass:
            return WellSampleRef.subclass(*args_, **kwargs_)
        else:
            return WellSampleRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_WellSampleID(self, value):
        # Validate type WellSampleID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_WellSampleID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_WellSampleID_patterns_, ))
    validate_WellSampleID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:WellSample:\\S+)|(WellSample:\\S+)$']]
    def hasContent_(self):
        if (
            super(WellSampleRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='WellSampleRef', mapping_=None):
        element = super(WellSampleRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_WellSampleID(self.ID)    # validate type WellSampleID
        super(WellSampleRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WellSampleRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WellSampleRef


class StructuredAnnotations(GeneratedsSuper):
    """An unordered collection of annotation attached to objects in the OME
    data model."""
    subclass = None
    superclass = None
    def __init__(self, XMLAnnotation=None, FileAnnotation=None, ListAnnotation=None, LongAnnotation=None, DoubleAnnotation=None, CommentAnnotation=None, BooleanAnnotation=None, TimestampAnnotation=None, TagAnnotation=None, TermAnnotation=None):
        self.original_tagname_ = None
        self.XMLAnnotation = XMLAnnotation
        self.FileAnnotation = FileAnnotation
        self.ListAnnotation = ListAnnotation
        self.LongAnnotation = LongAnnotation
        self.DoubleAnnotation = DoubleAnnotation
        self.CommentAnnotation = CommentAnnotation
        self.BooleanAnnotation = BooleanAnnotation
        self.TimestampAnnotation = TimestampAnnotation
        self.TagAnnotation = TagAnnotation
        self.TermAnnotation = TermAnnotation
    def factory(*args_, **kwargs_):
        if StructuredAnnotations.subclass:
            return StructuredAnnotations.subclass(*args_, **kwargs_)
        else:
            return StructuredAnnotations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XMLAnnotation(self): return self.XMLAnnotation
    def set_XMLAnnotation(self, XMLAnnotation): self.XMLAnnotation = XMLAnnotation
    def get_FileAnnotation(self): return self.FileAnnotation
    def set_FileAnnotation(self, FileAnnotation): self.FileAnnotation = FileAnnotation
    def get_ListAnnotation(self): return self.ListAnnotation
    def set_ListAnnotation(self, ListAnnotation): self.ListAnnotation = ListAnnotation
    def get_LongAnnotation(self): return self.LongAnnotation
    def set_LongAnnotation(self, LongAnnotation): self.LongAnnotation = LongAnnotation
    def get_DoubleAnnotation(self): return self.DoubleAnnotation
    def set_DoubleAnnotation(self, DoubleAnnotation): self.DoubleAnnotation = DoubleAnnotation
    def get_CommentAnnotation(self): return self.CommentAnnotation
    def set_CommentAnnotation(self, CommentAnnotation): self.CommentAnnotation = CommentAnnotation
    def get_BooleanAnnotation(self): return self.BooleanAnnotation
    def set_BooleanAnnotation(self, BooleanAnnotation): self.BooleanAnnotation = BooleanAnnotation
    def get_TimestampAnnotation(self): return self.TimestampAnnotation
    def set_TimestampAnnotation(self, TimestampAnnotation): self.TimestampAnnotation = TimestampAnnotation
    def get_TagAnnotation(self): return self.TagAnnotation
    def set_TagAnnotation(self, TagAnnotation): self.TagAnnotation = TagAnnotation
    def get_TermAnnotation(self): return self.TermAnnotation
    def set_TermAnnotation(self, TermAnnotation): self.TermAnnotation = TermAnnotation
    def hasContent_(self):
        if (
            self.XMLAnnotation is not None or
            self.FileAnnotation is not None or
            self.ListAnnotation is not None or
            self.LongAnnotation is not None or
            self.DoubleAnnotation is not None or
            self.CommentAnnotation is not None or
            self.BooleanAnnotation is not None or
            self.TimestampAnnotation is not None or
            self.TagAnnotation is not None or
            self.TermAnnotation is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='StructuredAnnotations', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.XMLAnnotation is not None:
            XMLAnnotation_ = self.XMLAnnotation
            XMLAnnotation_.to_etree(element, name_='XMLAnnotation', mapping_=mapping_)
        if self.FileAnnotation is not None:
            FileAnnotation_ = self.FileAnnotation
            FileAnnotation_.to_etree(element, name_='FileAnnotation', mapping_=mapping_)
        if self.ListAnnotation is not None:
            ListAnnotation_ = self.ListAnnotation
            ListAnnotation_.to_etree(element, name_='ListAnnotation', mapping_=mapping_)
        if self.LongAnnotation is not None:
            LongAnnotation_ = self.LongAnnotation
            LongAnnotation_.to_etree(element, name_='LongAnnotation', mapping_=mapping_)
        if self.DoubleAnnotation is not None:
            DoubleAnnotation_ = self.DoubleAnnotation
            DoubleAnnotation_.to_etree(element, name_='DoubleAnnotation', mapping_=mapping_)
        if self.CommentAnnotation is not None:
            CommentAnnotation_ = self.CommentAnnotation
            CommentAnnotation_.to_etree(element, name_='CommentAnnotation', mapping_=mapping_)
        if self.BooleanAnnotation is not None:
            BooleanAnnotation_ = self.BooleanAnnotation
            BooleanAnnotation_.to_etree(element, name_='BooleanAnnotation', mapping_=mapping_)
        if self.TimestampAnnotation is not None:
            TimestampAnnotation_ = self.TimestampAnnotation
            TimestampAnnotation_.to_etree(element, name_='TimestampAnnotation', mapping_=mapping_)
        if self.TagAnnotation is not None:
            TagAnnotation_ = self.TagAnnotation
            TagAnnotation_.to_etree(element, name_='TagAnnotation', mapping_=mapping_)
        if self.TermAnnotation is not None:
            TermAnnotation_ = self.TermAnnotation
            TermAnnotation_.to_etree(element, name_='TermAnnotation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XMLAnnotation':
            obj_ = XMLAnnotation.factory()
            obj_.build(child_)
            self.XMLAnnotation = obj_
            obj_.original_tagname_ = 'XMLAnnotation'
        elif nodeName_ == 'FileAnnotation':
            obj_ = FileAnnotation.factory()
            obj_.build(child_)
            self.FileAnnotation = obj_
            obj_.original_tagname_ = 'FileAnnotation'
        elif nodeName_ == 'ListAnnotation':
            obj_ = ListAnnotation.factory()
            obj_.build(child_)
            self.ListAnnotation = obj_
            obj_.original_tagname_ = 'ListAnnotation'
        elif nodeName_ == 'LongAnnotation':
            obj_ = LongAnnotation.factory()
            obj_.build(child_)
            self.LongAnnotation = obj_
            obj_.original_tagname_ = 'LongAnnotation'
        elif nodeName_ == 'DoubleAnnotation':
            obj_ = DoubleAnnotation.factory()
            obj_.build(child_)
            self.DoubleAnnotation = obj_
            obj_.original_tagname_ = 'DoubleAnnotation'
        elif nodeName_ == 'CommentAnnotation':
            obj_ = CommentAnnotation.factory()
            obj_.build(child_)
            self.CommentAnnotation = obj_
            obj_.original_tagname_ = 'CommentAnnotation'
        elif nodeName_ == 'BooleanAnnotation':
            obj_ = BooleanAnnotation.factory()
            obj_.build(child_)
            self.BooleanAnnotation = obj_
            obj_.original_tagname_ = 'BooleanAnnotation'
        elif nodeName_ == 'TimestampAnnotation':
            obj_ = TimestampAnnotation.factory()
            obj_.build(child_)
            self.TimestampAnnotation = obj_
            obj_.original_tagname_ = 'TimestampAnnotation'
        elif nodeName_ == 'TagAnnotation':
            obj_ = TagAnnotation.factory()
            obj_.build(child_)
            self.TagAnnotation = obj_
            obj_.original_tagname_ = 'TagAnnotation'
        elif nodeName_ == 'TermAnnotation':
            obj_ = TermAnnotation.factory()
            obj_.build(child_)
            self.TermAnnotation = obj_
            obj_.original_tagname_ = 'TermAnnotation'
# end class StructuredAnnotations


class AnnotationRef(Reference):
    """The AnnotationRef element is a reference to an element derived from
    the SA:CommonAnnotation element."""
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(AnnotationRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if AnnotationRef.subclass:
            return AnnotationRef.subclass(*args_, **kwargs_)
        else:
            return AnnotationRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_AnnotationID(self, value):
        # Validate type AnnotationID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AnnotationID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AnnotationID_patterns_, ))
    validate_AnnotationID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Annotation:\\S+)|(Annotation:\\S+)$']]
    def hasContent_(self):
        if (
            super(AnnotationRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='AnnotationRef', mapping_=None):
        element = super(AnnotationRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_AnnotationID(self.ID)    # validate type AnnotationID
        super(AnnotationRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AnnotationRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AnnotationRef


class Annotation(GeneratedsSuper):
    """An annotation from which the other are derived. We recommend the
    inclusion of a namespace for annotations you define. If it is
    absent then we assume the annotation is to use our (OME's)
    default interpretation for this type."""
    subclass = None
    superclass = None
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Namespace = _cast(None, Namespace)
        self.ID = _cast(None, ID)
        self.Description = Description
        self.validate_DescriptionType15(self.Description)
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DescriptionType15(self, value):
        # Validate type DescriptionType15, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AnnotationID(self, value):
        # Validate type AnnotationID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AnnotationID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AnnotationID_patterns_, ))
    validate_AnnotationID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Annotation:\\S+)|(Annotation:\\S+)$']]
    def hasContent_(self):
        if (
            self.Description is not None or
            self.AnnotationRef
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Annotation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.Namespace is not None:
            element.set('Namespace', self.gds_format_string(self.Namespace))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Namespace', node)
        if value is not None and 'Namespace' not in already_processed:
            already_processed.add('Namespace')
            self.Namespace = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_AnnotationID(self.ID)    # validate type AnnotationID
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType15(self.Description)    # validate type DescriptionType15
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
# end class Annotation


class FileAnnotation(Annotation):
    """A file object annotation"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, BinaryFile=None):
        self.original_tagname_ = None
        super(FileAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.BinaryFile = BinaryFile
    def factory(*args_, **kwargs_):
        if FileAnnotation.subclass:
            return FileAnnotation.subclass(*args_, **kwargs_)
        else:
            return FileAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BinaryFile(self): return self.BinaryFile
    def set_BinaryFile(self, BinaryFile): self.BinaryFile = BinaryFile
    def hasContent_(self):
        if (
            self.BinaryFile is not None or
            super(FileAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='FileAnnotation', mapping_=None):
        element = super(FileAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.BinaryFile is not None:
            BinaryFile_ = self.BinaryFile
            BinaryFile_.to_etree(element, name_='BinaryFile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BinaryFile':
            obj_ = BinaryFile.factory()
            obj_.build(child_)
            self.BinaryFile = obj_
            obj_.original_tagname_ = 'BinaryFile'
        super(FileAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class FileAnnotation


class XMLAnnotation(Annotation):
    """An general xml annotation. The contents of this is not processed as
    OME XML but should still be well-formed XML."""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(XMLAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if XMLAnnotation.subclass:
            return XMLAnnotation.subclass(*args_, **kwargs_)
        else:
            return XMLAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(XMLAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='XMLAnnotation', mapping_=None):
        element = super(XMLAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            Value_.to_etree(element, name_='Value', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XMLAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = ValueType.factory()
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
        super(XMLAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class XMLAnnotation


class ListAnnotation(Annotation):
    """This annotation is a grouping object. It uses the sequence of
    annotation refs from the base Annotation to form the list."""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None):
        self.original_tagname_ = None
        super(ListAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
    def factory(*args_, **kwargs_):
        if ListAnnotation.subclass:
            return ListAnnotation.subclass(*args_, **kwargs_)
        else:
            return ListAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ListAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ListAnnotation', mapping_=None):
        element = super(ListAnnotation, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ListAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ListAnnotation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ListAnnotation


class CommentAnnotation(Annotation):
    """A simple comment annotation"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(CommentAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CommentAnnotation.subclass:
            return CommentAnnotation.subclass(*args_, **kwargs_)
        else:
            return CommentAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(CommentAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='CommentAnnotation', mapping_=None):
        element = super(CommentAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_string(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CommentAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(CommentAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class CommentAnnotation


class LongAnnotation(Annotation):
    """A simple numerical annotation of type xsd:long"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(LongAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if LongAnnotation.subclass:
            return LongAnnotation.subclass(*args_, **kwargs_)
        else:
            return LongAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(LongAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='LongAnnotation', mapping_=None):
        element = super(LongAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_integer(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LongAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        super(LongAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class LongAnnotation


class DoubleAnnotation(Annotation):
    """A simple numerical annotation of type xsd:double"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(DoubleAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if DoubleAnnotation.subclass:
            return DoubleAnnotation.subclass(*args_, **kwargs_)
        else:
            return DoubleAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(DoubleAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='DoubleAnnotation', mapping_=None):
        element = super(DoubleAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_double(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DoubleAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
        super(DoubleAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class DoubleAnnotation


class BooleanAnnotation(Annotation):
    """A simple boolean annotation of type xsd:boolean"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(BooleanAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if BooleanAnnotation.subclass:
            return BooleanAnnotation.subclass(*args_, **kwargs_)
        else:
            return BooleanAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(BooleanAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='BooleanAnnotation', mapping_=None):
        element = super(BooleanAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_boolean(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BooleanAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Value')
            self.Value = ival_
        super(BooleanAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class BooleanAnnotation


class TimestampAnnotation(Annotation):
    """A date/time annotation of type xsd:dateTime"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(TimestampAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        if isinstance(Value, basestring):
            initvalue_ = datetime_.datetime.strptime(Value, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Value
        self.Value = initvalue_
    def factory(*args_, **kwargs_):
        if TimestampAnnotation.subclass:
            return TimestampAnnotation.subclass(*args_, **kwargs_)
        else:
            return TimestampAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(TimestampAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TimestampAnnotation', mapping_=None):
        element = super(TimestampAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_datetime(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimestampAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Value = dval_
        super(TimestampAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class TimestampAnnotation


class TagAnnotation(Annotation):
    """A tag annotation (represents a tag or a tagset)"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(TagAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if TagAnnotation.subclass:
            return TagAnnotation.subclass(*args_, **kwargs_)
        else:
            return TagAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(TagAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TagAnnotation', mapping_=None):
        element = super(TagAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_string(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TagAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(TagAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class TagAnnotation


class TermAnnotation(Annotation):
    """A ontology term annotation"""
    subclass = None
    superclass = Annotation
    def __init__(self, Namespace=None, ID=None, Description=None, AnnotationRef=None, Value=None):
        self.original_tagname_ = None
        super(TermAnnotation, self).__init__(Namespace, ID, Description, AnnotationRef, )
        self.Value = Value
    def factory(*args_, **kwargs_):
        if TermAnnotation.subclass:
            return TermAnnotation.subclass(*args_, **kwargs_)
        else:
            return TermAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(TermAnnotation, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='TermAnnotation', mapping_=None):
        element = super(TermAnnotation, self).to_etree(parent_element, name_, mapping_)
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_string(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TermAnnotation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(TermAnnotation, self).buildChildren(child_, node, nodeName_, True)
# end class TermAnnotation


class ROI(GeneratedsSuper):
    """A four dimensional 'Region of Interest'. If they are not used, and
    the Image has more than one plane, the entire set of planes is
    assumed to be included in the ROI. Multiple ROIs may be
    specified. The Name identifies the ROI to the user. [plane text
    string]"""
    subclass = None
    superclass = None
    def __init__(self, Namespace=None, ID=None, Name=None, Union=None, AnnotationRef=None, Description=None):
        self.original_tagname_ = None
        self.Namespace = _cast(None, Namespace)
        self.ID = _cast(None, ID)
        self.Name = _cast(None, Name)
        self.Union = Union
        if AnnotationRef is None:
            self.AnnotationRef = []
        else:
            self.AnnotationRef = AnnotationRef
        self.Description = Description
        self.validate_DescriptionType16(self.Description)
    def factory(*args_, **kwargs_):
        if ROI.subclass:
            return ROI.subclass(*args_, **kwargs_)
        else:
            return ROI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Union(self): return self.Union
    def set_Union(self, Union): self.Union = Union
    def get_AnnotationRef(self): return self.AnnotationRef
    def set_AnnotationRef(self, AnnotationRef): self.AnnotationRef = AnnotationRef
    def add_AnnotationRef(self, value): self.AnnotationRef.append(value)
    def insert_AnnotationRef_at(self, index, value): self.AnnotationRef.insert(index, value)
    def replace_AnnotationRef_at(self, index, value): self.AnnotationRef[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType16(self, value):
        # Validate type DescriptionType16, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ROIID(self, value):
        # Validate type ROIID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ROIID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ROIID_patterns_, ))
    validate_ROIID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:ROI:\\S+)|(ROI:\\S+)$']]
    def hasContent_(self):
        if (
            self.Union is not None or
            self.AnnotationRef or
            self.Description is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ROI', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Namespace is not None:
            element.set('Namespace', self.gds_format_string(self.Namespace))
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.Union is not None:
            Union_ = self.Union
            Union_.to_etree(element, name_='Union', mapping_=mapping_)
        for AnnotationRef_ in self.AnnotationRef:
            AnnotationRef_.to_etree(element, name_='AnnotationRef', mapping_=mapping_)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Namespace', node)
        if value is not None and 'Namespace' not in already_processed:
            already_processed.add('Namespace')
            self.Namespace = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ROIID(self.ID)    # validate type ROIID
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Union':
            obj_ = UnionType.factory()
            obj_.build(child_)
            self.Union = obj_
            obj_.original_tagname_ = 'Union'
        elif nodeName_ == 'AnnotationRef':
            obj_ = AnnotationRef.factory()
            obj_.build(child_)
            self.AnnotationRef.append(obj_)
            obj_.original_tagname_ = 'AnnotationRef'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType16(self.Description)    # validate type DescriptionType16
# end class ROI


class Shape(GeneratedsSuper):
    """The shape element contains a single specific ROI shape and links
    that to any channels, and a timepoint and a z-section. It also
    records any transform applied to the ROI shape. The Name
    identifies the Shape to the user. [plane text string] The colour
    of the fill - encoded as RGBA The value "-2147483648" is
    #FFFFFFFF so solid white (it is a signed 32 bit value) The rule
    used to decide which parts of the shape to fill. [enumeration]
    The colour of the stroke - encoded as RGBA The value
    "-2147483648" is #FFFFFFFF so solid white (it is a signed 32 bit
    value) The width of the stroke [units pixels] e.g. "none", "10
    20 30 10" The shape of the end of the line. [enumeration] The
    font family used to draw the text. [enumeration] Size of the
    font [units points] The style and weight applied to the text.
    [enumeration] The z-section the ROI applies to. If not specified
    then the ROI applies to all the z-sections of the image.
    [units:none] This is numbered from 0. The timepoint the ROI
    applies to. If not specified then the ROI applies to all the
    timepoints of the image. [units:none] This is numbered from 0.
    The channel the ROI applies to. If not specified then the ROI
    applies to all the channels of the image. [units:none] This is
    numbered from 0. This is a matrix used to transform the the
    shape. It is a string of 6 numbers "a, b, c, d, e, f" that
    represent the 3 by 3 matrix. -- -- | a, c, e | | b, d, f | | 0,
    0, 1 | -- --"""
    subclass = None
    superclass = None
    def __init__(self, StrokeDashArray=None, StrokeWidth=None, FillRule=None, LineCap=None, TheC=None, TheT=None, Transform=None, Label=None, FontFamily=None, Stroke=None, FontStyle=None, MarkerEnd=None, TheZ=None, FontSize=None, ID=None, Fill=None, MarkerStart=None, Name=None, Line=None, Rectangle=None, Mask=None, Ellipse=None, Point=None, Polyline=None, Path=None, Text=None, Description=None):
        self.original_tagname_ = None
        self.StrokeDashArray = _cast(None, StrokeDashArray)
        self.StrokeWidth = _cast(float, StrokeWidth)
        self.FillRule = _cast(None, FillRule)
        self.LineCap = _cast(None, LineCap)
        self.TheC = _cast(None, TheC)
        self.TheT = _cast(None, TheT)
        self.Transform = _cast(None, Transform)
        self.Label = _cast(None, Label)
        self.FontFamily = _cast(None, FontFamily)
        self.Stroke = _cast(int, Stroke)
        self.FontStyle = _cast(None, FontStyle)
        self.MarkerEnd = _cast(None, MarkerEnd)
        self.TheZ = _cast(None, TheZ)
        self.FontSize = _cast(None, FontSize)
        self.ID = _cast(None, ID)
        self.Fill = _cast(int, Fill)
        self.MarkerStart = _cast(None, MarkerStart)
        self.Name = _cast(None, Name)
        self.Line = Line
        self.Rectangle = Rectangle
        self.Mask = Mask
        self.Ellipse = Ellipse
        self.Point = Point
        self.Polyline = Polyline
        self.Path = Path
        self.Text = Text
        self.Description = Description
        self.validate_DescriptionType17(self.Description)
    def factory(*args_, **kwargs_):
        if Shape.subclass:
            return Shape.subclass(*args_, **kwargs_)
        else:
            return Shape(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Line(self): return self.Line
    def set_Line(self, Line): self.Line = Line
    def get_Rectangle(self): return self.Rectangle
    def set_Rectangle(self, Rectangle): self.Rectangle = Rectangle
    def get_Mask(self): return self.Mask
    def set_Mask(self, Mask): self.Mask = Mask
    def get_Ellipse(self): return self.Ellipse
    def set_Ellipse(self, Ellipse): self.Ellipse = Ellipse
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def get_Polyline(self): return self.Polyline
    def set_Polyline(self, Polyline): self.Polyline = Polyline
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_StrokeDashArray(self): return self.StrokeDashArray
    def set_StrokeDashArray(self, StrokeDashArray): self.StrokeDashArray = StrokeDashArray
    def get_StrokeWidth(self): return self.StrokeWidth
    def set_StrokeWidth(self, StrokeWidth): self.StrokeWidth = StrokeWidth
    def get_FillRule(self): return self.FillRule
    def set_FillRule(self, FillRule): self.FillRule = FillRule
    def get_LineCap(self): return self.LineCap
    def set_LineCap(self, LineCap): self.LineCap = LineCap
    def get_TheC(self): return self.TheC
    def set_TheC(self, TheC): self.TheC = TheC
    def get_TheT(self): return self.TheT
    def set_TheT(self, TheT): self.TheT = TheT
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_FontFamily(self): return self.FontFamily
    def set_FontFamily(self, FontFamily): self.FontFamily = FontFamily
    def get_Stroke(self): return self.Stroke
    def set_Stroke(self, Stroke): self.Stroke = Stroke
    def get_FontStyle(self): return self.FontStyle
    def set_FontStyle(self, FontStyle): self.FontStyle = FontStyle
    def get_MarkerEnd(self): return self.MarkerEnd
    def set_MarkerEnd(self, MarkerEnd): self.MarkerEnd = MarkerEnd
    def get_TheZ(self): return self.TheZ
    def set_TheZ(self, TheZ): self.TheZ = TheZ
    def get_FontSize(self): return self.FontSize
    def set_FontSize(self, FontSize): self.FontSize = FontSize
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Fill(self): return self.Fill
    def set_Fill(self, Fill): self.Fill = Fill
    def get_MarkerStart(self): return self.MarkerStart
    def set_MarkerStart(self, MarkerStart): self.MarkerStart = MarkerStart
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def validate_DescriptionType17(self, value):
        # Validate type DescriptionType17, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Marker(self, value):
        # Validate type Marker, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Arrow', 'Circle', 'Square']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Marker' % {"value" : value.encode("utf-8")} )
    def validate_ShapeID(self, value):
        # Validate type ShapeID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ShapeID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ShapeID_patterns_, ))
    validate_ShapeID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Shape:\\S+)|(Shape:\\S+)$']]
    def hasContent_(self):
        if (
            self.Line is not None or
            self.Rectangle is not None or
            self.Mask is not None or
            self.Ellipse is not None or
            self.Point is not None or
            self.Polyline is not None or
            self.Path is not None or
            self.Text is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Shape', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.StrokeDashArray is not None:
            element.set('StrokeDashArray', self.gds_format_string(self.StrokeDashArray))
        if self.StrokeWidth is not None:
            element.set('StrokeWidth', self.gds_format_float(self.StrokeWidth))
        if self.FillRule is not None:
            element.set('FillRule', self.gds_format_string(self.FillRule))
        if self.LineCap is not None:
            element.set('LineCap', self.gds_format_string(self.LineCap))
        if self.TheC is not None:
            element.set('TheC', self.TheC)
        if self.TheT is not None:
            element.set('TheT', self.TheT)
        if self.Transform is not None:
            element.set('Transform', self.gds_format_string(self.Transform))
        if self.Label is not None:
            element.set('Label', self.gds_format_string(self.Label))
        if self.FontFamily is not None:
            element.set('FontFamily', self.gds_format_string(self.FontFamily))
        if self.Stroke is not None:
            element.set('Stroke', self.gds_format_integer(self.Stroke))
        if self.FontStyle is not None:
            element.set('FontStyle', self.gds_format_string(self.FontStyle))
        if self.MarkerEnd is not None:
            element.set('MarkerEnd', self.MarkerEnd)
        if self.TheZ is not None:
            element.set('TheZ', self.TheZ)
        if self.FontSize is not None:
            element.set('FontSize', self.FontSize)
        if self.ID is not None:
            element.set('ID', self.ID)
        if self.Fill is not None:
            element.set('Fill', self.gds_format_integer(self.Fill))
        if self.MarkerStart is not None:
            element.set('MarkerStart', self.MarkerStart)
        if self.Name is not None:
            element.set('Name', self.gds_format_string(self.Name))
        if self.Line is not None:
            Line_ = self.Line
            Line_.to_etree(element, name_='Line', mapping_=mapping_)
        if self.Rectangle is not None:
            Rectangle_ = self.Rectangle
            Rectangle_.to_etree(element, name_='Rectangle', mapping_=mapping_)
        if self.Mask is not None:
            Mask_ = self.Mask
            Mask_.to_etree(element, name_='Mask', mapping_=mapping_)
        if self.Ellipse is not None:
            Ellipse_ = self.Ellipse
            Ellipse_.to_etree(element, name_='Ellipse', mapping_=mapping_)
        if self.Point is not None:
            Point_ = self.Point
            Point_.to_etree(element, name_='Point', mapping_=mapping_)
        if self.Polyline is not None:
            Polyline_ = self.Polyline
            Polyline_.to_etree(element, name_='Polyline', mapping_=mapping_)
        if self.Path is not None:
            Path_ = self.Path
            Path_.to_etree(element, name_='Path', mapping_=mapping_)
        if self.Text is not None:
            Text_ = self.Text
            Text_.to_etree(element, name_='Text', mapping_=mapping_)
        if self.Description is not None:
            Description_ = self.Description
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Description').text = self.gds_format_string(Description_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StrokeDashArray', node)
        if value is not None and 'StrokeDashArray' not in already_processed:
            already_processed.add('StrokeDashArray')
            self.StrokeDashArray = value
        value = find_attr_value_('StrokeWidth', node)
        if value is not None and 'StrokeWidth' not in already_processed:
            already_processed.add('StrokeWidth')
            try:
                self.StrokeWidth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (StrokeWidth): %s' % exp)
        value = find_attr_value_('FillRule', node)
        if value is not None and 'FillRule' not in already_processed:
            already_processed.add('FillRule')
            self.FillRule = value
        value = find_attr_value_('LineCap', node)
        if value is not None and 'LineCap' not in already_processed:
            already_processed.add('LineCap')
            self.LineCap = value
        value = find_attr_value_('TheC', node)
        if value is not None and 'TheC' not in already_processed:
            already_processed.add('TheC')
            self.TheC = value
        value = find_attr_value_('TheT', node)
        if value is not None and 'TheT' not in already_processed:
            already_processed.add('TheT')
            self.TheT = value
        value = find_attr_value_('Transform', node)
        if value is not None and 'Transform' not in already_processed:
            already_processed.add('Transform')
            self.Transform = value
        value = find_attr_value_('Label', node)
        if value is not None and 'Label' not in already_processed:
            already_processed.add('Label')
            self.Label = value
        value = find_attr_value_('FontFamily', node)
        if value is not None and 'FontFamily' not in already_processed:
            already_processed.add('FontFamily')
            self.FontFamily = value
        value = find_attr_value_('Stroke', node)
        if value is not None and 'Stroke' not in already_processed:
            already_processed.add('Stroke')
            try:
                self.Stroke = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('FontStyle', node)
        if value is not None and 'FontStyle' not in already_processed:
            already_processed.add('FontStyle')
            self.FontStyle = value
        value = find_attr_value_('MarkerEnd', node)
        if value is not None and 'MarkerEnd' not in already_processed:
            already_processed.add('MarkerEnd')
            self.MarkerEnd = value
            self.validate_Marker(self.MarkerEnd)    # validate type Marker
        value = find_attr_value_('TheZ', node)
        if value is not None and 'TheZ' not in already_processed:
            already_processed.add('TheZ')
            self.TheZ = value
        value = find_attr_value_('FontSize', node)
        if value is not None and 'FontSize' not in already_processed:
            already_processed.add('FontSize')
            self.FontSize = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ShapeID(self.ID)    # validate type ShapeID
        value = find_attr_value_('Fill', node)
        if value is not None and 'Fill' not in already_processed:
            already_processed.add('Fill')
            try:
                self.Fill = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('MarkerStart', node)
        if value is not None and 'MarkerStart' not in already_processed:
            already_processed.add('MarkerStart')
            self.MarkerStart = value
            self.validate_Marker(self.MarkerStart)    # validate type Marker
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Line':
            obj_ = Line.factory()
            obj_.build(child_)
            self.Line = obj_
            obj_.original_tagname_ = 'Line'
        elif nodeName_ == 'Rectangle':
            obj_ = Rectangle.factory()
            obj_.build(child_)
            self.Rectangle = obj_
            obj_.original_tagname_ = 'Rectangle'
        elif nodeName_ == 'Mask':
            obj_ = Mask.factory()
            obj_.build(child_)
            self.Mask = obj_
            obj_.original_tagname_ = 'Mask'
        elif nodeName_ == 'Ellipse':
            obj_ = Ellipse.factory()
            obj_.build(child_)
            self.Ellipse = obj_
            obj_.original_tagname_ = 'Ellipse'
        elif nodeName_ == 'Point':
            obj_ = Point.factory()
            obj_.build(child_)
            self.Point = obj_
            obj_.original_tagname_ = 'Point'
        elif nodeName_ == 'Polyline':
            obj_ = Polyline.factory()
            obj_.build(child_)
            self.Polyline = obj_
            obj_.original_tagname_ = 'Polyline'
        elif nodeName_ == 'Path':
            obj_ = Path.factory()
            obj_.build(child_)
            self.Path = obj_
            obj_.original_tagname_ = 'Path'
        elif nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            self.validate_DescriptionType17(self.Description)    # validate type DescriptionType17
# end class Shape


class Rectangle(GeneratedsSuper):
    """A simple rectangle object. If rotation is required apply a
    transformation at the Shape level. The X value of the left edge
    or the rectangle. [units pixels] The y value of the top edge or
    the rectangle. [units pixels] The width of the rectangle. [units
    pixels] The height of the rectangle. [units pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, Height=None, Width=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.Height = _cast(float, Height)
        self.Width = _cast(float, Width)
    def factory(*args_, **kwargs_):
        if Rectangle.subclass:
            return Rectangle.subclass(*args_, **kwargs_)
        else:
            return Rectangle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Rectangle', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if self.Height is not None:
            element.set('Height', self.gds_format_float(self.Height))
        if self.Width is not None:
            element.set('Width', self.gds_format_float(self.Width))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Height): %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Width): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Rectangle


class Mask(GeneratedsSuper):
    """The Mask ROI shape is a link to a BIN:BinData object that is a BIT
    mask drawn on top of the image as an ROI. It is applied at the
    same scale, pixel to pixel, as the Image the ROI is applied to,
    unless a transform is applied at the shape level. The X
    coordinate of the left side of the image. [units pixels] The Y
    coordinate of the top side of the image. [units pixels] The
    width of the mask. [units pixels] The height of the mask. [units
    pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, Height=None, Width=None, BinData=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.Height = _cast(float, Height)
        self.Width = _cast(float, Width)
        if BinData is None:
            self.BinData = []
        else:
            self.BinData = BinData
    def factory(*args_, **kwargs_):
        if Mask.subclass:
            return Mask.subclass(*args_, **kwargs_)
        else:
            return Mask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BinData(self): return self.BinData
    def set_BinData(self, BinData): self.BinData = BinData
    def add_BinData(self, value): self.BinData.append(value)
    def insert_BinData_at(self, index, value): self.BinData.insert(index, value)
    def replace_BinData_at(self, index, value): self.BinData[index] = value
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def hasContent_(self):
        if (
            self.BinData
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Mask', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if self.Height is not None:
            element.set('Height', self.gds_format_float(self.Height))
        if self.Width is not None:
            element.set('Width', self.gds_format_float(self.Width))
        for BinData_ in self.BinData:
            BinData_.to_etree(element, name_='BinData', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
        value = find_attr_value_('Height', node)
        if value is not None and 'Height' not in already_processed:
            already_processed.add('Height')
            try:
                self.Height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Height): %s' % exp)
        value = find_attr_value_('Width', node)
        if value is not None and 'Width' not in already_processed:
            already_processed.add('Width')
            try:
                self.Width = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Width): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BinData':
            obj_ = BinData.factory()
            obj_.build(child_)
            self.BinData.append(obj_)
            obj_.original_tagname_ = 'BinData'
# end class Mask


class Point(GeneratedsSuper):
    """The X coordinate of the point. [units pixels] The Y coordinate of
    the point. [units pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Point', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class Ellipse(GeneratedsSuper):
    """A simple ellipse object. If rotation is required apply a
    transformation at the Shape level. The X coordinate of the
    center of the ellipse. [units pixels] The Y coordinate of the
    center of the ellipse. [units pixels] The horizontal radius of
    the ellipse. [units pixels] The vertical radius of the ellipse.
    [units pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, RadiusY=None, RadiusX=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.RadiusY = _cast(float, RadiusY)
        self.RadiusX = _cast(float, RadiusX)
    def factory(*args_, **kwargs_):
        if Ellipse.subclass:
            return Ellipse.subclass(*args_, **kwargs_)
        else:
            return Ellipse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_RadiusY(self): return self.RadiusY
    def set_RadiusY(self, RadiusY): self.RadiusY = RadiusY
    def get_RadiusX(self): return self.RadiusX
    def set_RadiusX(self, RadiusX): self.RadiusX = RadiusX
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Ellipse', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if self.RadiusY is not None:
            element.set('RadiusY', self.gds_format_float(self.RadiusY))
        if self.RadiusX is not None:
            element.set('RadiusX', self.gds_format_float(self.RadiusX))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
        value = find_attr_value_('RadiusY', node)
        if value is not None and 'RadiusY' not in already_processed:
            already_processed.add('RadiusY')
            try:
                self.RadiusY = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RadiusY): %s' % exp)
        value = find_attr_value_('RadiusX', node)
        if value is not None and 'RadiusX' not in already_processed:
            already_processed.add('RadiusX')
            try:
                self.RadiusX = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (RadiusX): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Ellipse


class Line(GeneratedsSuper):
    """A straight line defined by it's end points. The X coordinate of the
    start of the line. [units pixels] The Y coordinate of the start
    of the line. [units pixels] The X coordinate of the end of the
    line. [units pixels] The Y coordinate of the end of the line.
    [units pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y1=None, X2=None, X1=None, Y2=None):
        self.original_tagname_ = None
        self.Y1 = _cast(float, Y1)
        self.X2 = _cast(float, X2)
        self.X1 = _cast(float, X1)
        self.Y2 = _cast(float, Y2)
    def factory(*args_, **kwargs_):
        if Line.subclass:
            return Line.subclass(*args_, **kwargs_)
        else:
            return Line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Y1(self): return self.Y1
    def set_Y1(self, Y1): self.Y1 = Y1
    def get_X2(self): return self.X2
    def set_X2(self, X2): self.X2 = X2
    def get_X1(self): return self.X1
    def set_X1(self, X1): self.X1 = X1
    def get_Y2(self): return self.Y2
    def set_Y2(self, Y2): self.Y2 = Y2
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Line', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y1 is not None:
            element.set('Y1', self.gds_format_float(self.Y1))
        if self.X2 is not None:
            element.set('X2', self.gds_format_float(self.X2))
        if self.X1 is not None:
            element.set('X1', self.gds_format_float(self.X1))
        if self.Y2 is not None:
            element.set('Y2', self.gds_format_float(self.Y2))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y1', node)
        if value is not None and 'Y1' not in already_processed:
            already_processed.add('Y1')
            try:
                self.Y1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y1): %s' % exp)
        value = find_attr_value_('X2', node)
        if value is not None and 'X2' not in already_processed:
            already_processed.add('X2')
            try:
                self.X2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X2): %s' % exp)
        value = find_attr_value_('X1', node)
        if value is not None and 'X1' not in already_processed:
            already_processed.add('X1')
            try:
                self.X1 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X1): %s' % exp)
        value = find_attr_value_('Y2', node)
        if value is not None and 'Y2' not in already_processed:
            already_processed.add('Y2')
            try:
                self.Y2 = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y2): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Line


class Polyline(GeneratedsSuper):
    """The Polyline defines open and closed shapes formed of straight
    lines. Note: Polyline uses counterclockwise winding (this is the
    default OpenGL behavior) The points of the polyline are defined
    as a list of comma separated x,y coordinates seperated by spaces
    like "x1,y1 x2,y2 x3,y3" e.g. "0,0 1,2 3,5" Indicates if the
    shape is closed with an extra line form the end point back to
    the start point. [flag]"""
    subclass = None
    superclass = None
    def __init__(self, Points=None, Closed=False):
        self.original_tagname_ = None
        self.Points = _cast(None, Points)
        self.Closed = _cast(bool, Closed)
    def factory(*args_, **kwargs_):
        if Polyline.subclass:
            return Polyline.subclass(*args_, **kwargs_)
        else:
            return Polyline(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Points(self): return self.Points
    def set_Points(self, Points): self.Points = Points
    def get_Closed(self): return self.Closed
    def set_Closed(self, Closed): self.Closed = Closed
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Polyline', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Points is not None:
            element.set('Points', self.gds_format_string(self.Points))
        if self.Closed is not None:
            element.set('Closed', self.gds_format_boolean(self.Closed))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Points', node)
        if value is not None and 'Points' not in already_processed:
            already_processed.add('Points')
            self.Points = value
        value = find_attr_value_('Closed', node)
        if value is not None and 'Closed' not in already_processed:
            already_processed.add('Closed')
            if value in ('true', '1'):
                self.Closed = True
            elif value in ('false', '0'):
                self.Closed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Polyline


class Path(GeneratedsSuper):
    """A path is a complex shape that can consists of straight and curved
    sections. It is defined as a collection of drawing commands. The
    commands are listed in the string separated by spaces. The
    following commands are available: M = moveto (absolute) L =
    lineto (absolute) H = horizontal lineto (absolute) V = vertical
    lineto (absolute) C = curveto (absolute) S = smooth curveto
    (absolute) Q = quadratic Bezier curve (absolute) T = smooth
    quadratic Bezier curveto (absolute) A = elliptical Arc
    (absolute) Z = closepath m = moveto (relative) l = lineto
    (relative) h = horizontal lineto (relative) v = vertical lineto
    (relative) c = curveto (relative) s = smooth curveto (relative)
    q = quadratic Bezier curve (relative) t = smooth quadratic
    Bezier curveto (relative) a = elliptical Arc (relative) z =
    closepath"""
    subclass = None
    superclass = None
    def __init__(self, Definition=None):
        self.original_tagname_ = None
        self.Definition = _cast(None, Definition)
    def factory(*args_, **kwargs_):
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Definition(self): return self.Definition
    def set_Definition(self, Definition): self.Definition = Definition
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Path', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Definition is not None:
            element.set('Definition', self.gds_format_string(self.Definition))
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Definition', node)
        if value is not None and 'Definition' not in already_processed:
            already_processed.add('Definition')
            self.Definition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Path


class Text(GeneratedsSuper):
    """The text annotation. Any transformation should be applied at the
    shape level. This defines the X coordinate of the current text
    position of the first character in the string. [units pixels]
    This defines the X coordinate of the current text position of
    the first character in the string. [units pixels]"""
    subclass = None
    superclass = None
    def __init__(self, Y=None, X=None, Value=None):
        self.original_tagname_ = None
        self.Y = _cast(float, Y)
        self.X = _cast(float, X)
        self.Value = Value
        self.validate_ValueType18(self.Value)
    def factory(*args_, **kwargs_):
        if Text.subclass:
            return Text.subclass(*args_, **kwargs_)
        else:
            return Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def validate_ValueType18(self, value):
        # Validate type ValueType18, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Value is not None
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='Text', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.Y is not None:
            element.set('Y', self.gds_format_float(self.Y))
        if self.X is not None:
            element.set('X', self.gds_format_float(self.X))
        if self.Value is not None:
            Value_ = self.Value
            etree_.SubElement(element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}Value').text = self.gds_format_string(Value_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Y', node)
        if value is not None and 'Y' not in already_processed:
            already_processed.add('Y')
            try:
                self.Y = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Y): %s' % exp)
        value = find_attr_value_('X', node)
        if value is not None and 'X' not in already_processed:
            already_processed.add('X')
            try:
                self.X = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (X): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
            self.validate_ValueType18(self.Value)    # validate type ValueType18
# end class Text


class ROIRef(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ROIRef, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ROIRef.subclass:
            return ROIRef.subclass(*args_, **kwargs_)
        else:
            return ROIRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ROIID(self, value):
        # Validate type ROIID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ROIID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ROIID_patterns_, ))
    validate_ROIID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:ROI:\\S+)|(ROI:\\S+)$']]
    def hasContent_(self):
        if (
            super(ROIRef, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ROIRef', mapping_=None):
        element = super(ROIRef, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ROIID(self.ID)    # validate type ROIID
        super(ROIRef, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ROIRef, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ROIRef


class UUIDType(GeneratedsSuper):
    """ This can be used when the IFDs are located in another file. The /
    (forward slash) is used as the path separator. A relative path
    is recommended. However an absolute path can be specified.
    Default is to use the file the ome-xml data has been pulled
    from. Note: It is permissible for this to be self referential.
    The file image1.tiff may contain ome-xml data that has
    FilePath="image1.tiff" or "./image1.tiff" """
    subclass = None
    superclass = None
    def __init__(self, FileName=None, valueOf_=None):
        self.original_tagname_ = None
        self.FileName = _cast(None, FileName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UUIDType.subclass:
            return UUIDType.subclass(*args_, **kwargs_)
        else:
            return UUIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileName(self): return self.FileName
    def set_FileName(self, FileName): self.FileName = FileName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UUIDType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.FileName is not None:
            element.set('FileName', self.gds_format_string(self.FileName))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FileName', node)
        if value is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            self.FileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UUIDType


class UUIDType6(GeneratedsSuper):
    """ This can be used when the IFDs are located in another file. The /
    (forward slash) is used as the path separator. A relative path
    is recommended. However an absolute path can be specified.
    Default is to use the file the ome-xml data has been pulled
    from. Note: It is permissible for this to be self referential.
    The file image1.tiff may contain ome-xml data that has
    FilePath="image1.tiff" or "./image1.tiff" """
    subclass = None
    superclass = None
    def __init__(self, FileName=None, valueOf_=None):
        self.original_tagname_ = None
        self.FileName = _cast(None, FileName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UUIDType6.subclass:
            return UUIDType6.subclass(*args_, **kwargs_)
        else:
            return UUIDType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileName(self): return self.FileName
    def set_FileName(self, FileName): self.FileName = FileName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UUIDType6', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        if self.FileName is not None:
            element.set('FileName', self.gds_format_string(self.FileName))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FileName', node)
        if value is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            self.FileName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UUIDType6


class ScreenRefType(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(ScreenRefType, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if ScreenRefType.subclass:
            return ScreenRefType.subclass(*args_, **kwargs_)
        else:
            return ScreenRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_ScreenID(self, value):
        # Validate type ScreenID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ScreenID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ScreenID_patterns_, ))
    validate_ScreenID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Screen:\\S+)|(Screen:\\S+)$']]
    def hasContent_(self):
        if (
            super(ScreenRefType, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ScreenRefType', mapping_=None):
        element = super(ScreenRefType, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_ScreenID(self.ID)    # validate type ScreenID
        super(ScreenRefType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ScreenRefType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ScreenRefType


class PlateRefType(Reference):
    subclass = None
    superclass = Reference
    def __init__(self, ID=None):
        self.original_tagname_ = None
        super(PlateRefType, self).__init__()
        self.ID = _cast(None, ID)
    def factory(*args_, **kwargs_):
        if PlateRefType.subclass:
            return PlateRefType.subclass(*args_, **kwargs_)
        else:
            return PlateRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def validate_PlateID(self, value):
        # Validate type PlateID, a restriction on OME:LSID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlateID_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlateID_patterns_, ))
    validate_PlateID_patterns_ = [['^(urn:lsid:([\\w\\-\\.]+\\.[\\w\\-\\.]+)+:Plate:\\S+)|(Plate:\\S+)$']]
    def hasContent_(self):
        if (
            super(PlateRefType, self).hasContent_()
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='PlateRefType', mapping_=None):
        element = super(PlateRefType, self).to_etree(parent_element, name_, mapping_)
        if self.ID is not None:
            element.set('ID', self.ID)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
            self.validate_PlateID(self.ID)    # validate type PlateID
        super(PlateRefType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PlateRefType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PlateRefType


class ValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='ValueType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        for obj_ in self.anytypeobjs_:
            obj_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'ValueType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class ValueType


class UnionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Shape=None):
        self.original_tagname_ = None
        if Shape is None:
            self.Shape = []
        else:
            self.Shape = Shape
    def factory(*args_, **kwargs_):
        if UnionType.subclass:
            return UnionType.subclass(*args_, **kwargs_)
        else:
            return UnionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self): return self.Shape
    def set_Shape(self, Shape): self.Shape = Shape
    def add_Shape(self, value): self.Shape.append(value)
    def insert_Shape_at(self, index, value): self.Shape.insert(index, value)
    def replace_Shape_at(self, index, value): self.Shape[index] = value
    def hasContent_(self):
        if (
            self.Shape
        ):
            return True
        else:
            return False
    def to_etree(self, parent_element=None, name_='UnionType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.openmicroscopy.org/Schemas/OME/2010-06}' + name_)
        for Shape_ in self.Shape:
            Shape_.to_etree(element, name_='Shape', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            obj_ = Shape.factory()
            obj_.build(child_)
            self.Shape.append(obj_)
            obj_.original_tagname_ = 'Shape'
# end class UnionType


GDSClassesMapping = {
    'UUID': UUIDType6,
    'Union': UnionType,
    'Value': ValueType,
    'PlateRef': PlateRefType,
    'ExcitationFilterRef': FilterRef,
    'ScreenRef': ScreenRefType,
    'EmissionFilterRef': FilterRef,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OME'
        rootClass = OME
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:OME="http://www.openmicroscopy.org/Schemas/OME/2010-06"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OME'
        rootClass = OME
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OME'
        rootClass = OME
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:OME="http://www.openmicroscopy.org/Schemas/OME/2010-06"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'OME'
        rootClass = OME
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ome import *\n\n')
        sys.stdout.write('import ome as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Annotation",
    "AnnotationRef",
    "Arc",
    "BinData",
    "BinaryFile",
    "BooleanAnnotation",
    "Channel",
    "ChannelRef",
    "CommentAnnotation",
    "Contact",
    "Dataset",
    "DatasetRef",
    "Detector",
    "DetectorSettings",
    "Dichroic",
    "DichroicRef",
    "DoubleAnnotation",
    "Ellipse",
    "Experiment",
    "ExperimentRef",
    "Experimenter",
    "ExperimenterRef",
    "External",
    "Filament",
    "FileAnnotation",
    "Filter",
    "FilterRef",
    "FilterSet",
    "FilterSetRef",
    "Group",
    "GroupRef",
    "Image",
    "ImageRef",
    "ImagingEnvironment",
    "Instrument",
    "InstrumentRef",
    "Laser",
    "Leader",
    "LightEmittingDiode",
    "LightPath",
    "LightSource",
    "LightSourceSettings",
    "Line",
    "ListAnnotation",
    "LongAnnotation",
    "ManufacturerSpec",
    "Mask",
    "MetadataOnly",
    "MicrobeamManipulation",
    "MicrobeamManipulationRef",
    "Microscope",
    "OME",
    "OTF",
    "OTFRef",
    "Objective",
    "ObjectiveSettings",
    "Path",
    "Pixels",
    "Plane",
    "Plate",
    "PlateAcquisition",
    "PlateRefType",
    "Point",
    "Polyline",
    "Project",
    "ProjectRef",
    "Pump",
    "ROI",
    "ROIRef",
    "Reagent",
    "ReagentRef",
    "Rectangle",
    "Reference",
    "Screen",
    "ScreenRefType",
    "Settings",
    "Shape",
    "StageLabel",
    "StructuredAnnotations",
    "TagAnnotation",
    "TermAnnotation",
    "Text",
    "TiffData",
    "TimestampAnnotation",
    "TransmittanceRange",
    "UUIDType",
    "UUIDType6",
    "UnionType",
    "ValueType",
    "Well",
    "WellSample",
    "WellSampleRef",
    "XMLAnnotation"
]
